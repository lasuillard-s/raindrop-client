/* tslint:disable */
/* eslint-disable */
/**
 * Raindrop API (Unofficial)
 * **UNOFFICIAL** OpenAPI specification of Raindrop API.  This OpenAPI spec has been made by hand with reference to official documentation because it is not provided by Raindrop.io.  Because official documentation not maintained well, there are very (highly) likely to have mismatch in schemas. As we can\'t inspect and address all issues, schema being updated as we find issues.  Any contributions are welcome. Bug report, schema update, adding descriptions or functions, please don\'t hesitate to create an issue.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptInvitation200Response
 */
export interface AcceptInvitation200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptInvitation200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {Role}
     * @memberof AcceptInvitation200Response
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface Bookmark
 */
export interface Bookmark {
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'lastUpdate': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bookmark
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'excerpt': string;
}
/**
 * 
 * @export
 * @interface ChangeCollaboratorAccessLevelRequest
 */
export interface ChangeCollaboratorAccessLevelRequest {
    /**
     * 
     * @type {Role}
     * @memberof ChangeCollaboratorAccessLevelRequest
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface CheckURLsExist200Response
 */
export interface CheckURLsExist200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CheckURLsExist200Response
     */
    'result': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CheckURLsExist200Response
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CheckURLsExistRequest
 */
export interface CheckURLsExistRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckURLsExistRequest
     */
    'urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof Collection
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Collection
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof Collection
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof Collection
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'author': boolean;
}
/**
 * 
 * @export
 * @interface CollectionAccess
 */
export interface CollectionAccess {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAccess
     */
    'draggable': boolean;
    /**
     * 
     * @type {number}
     * @memberof CollectionAccess
     */
    'for': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionAccess
     */
    'level': number;
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAccess
     */
    'root': boolean;
}
/**
 * 
 * @export
 * @interface CollectionRef
 */
export interface CollectionRef {
    /**
     * 
     * @type {string}
     * @memberof CollectionRef
     */
    '$ref': CollectionRefRefEnum;
    /**
     * 
     * @type {number}
     * @memberof CollectionRef
     */
    '$id': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionRef
     */
    'oid'?: number;
}

export const CollectionRefRefEnum = {
    Collections: 'collections'
} as const;

export type CollectionRefRefEnum = typeof CollectionRefRefEnum[keyof typeof CollectionRefRefEnum];

/**
 * 
 * @export
 * @interface CollectionResponseMany
 */
export interface CollectionResponseMany {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionResponseMany
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Collection>}
     * @memberof CollectionResponseMany
     */
    'items': Array<Collection>;
}
/**
 * 
 * @export
 * @interface CollectionResponseOne
 */
export interface CollectionResponseOne {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionResponseOne
     */
    'result': boolean;
    /**
     * 
     * @type {Collection}
     * @memberof CollectionResponseOne
     */
    'item'?: Collection;
}
/**
 * 
 * @export
 * @interface Cover
 */
export interface Cover {
    /**
     * 
     * @type {string}
     * @memberof Cover
     */
    'title': string;
    /**
     * 
     * @type {Array<CoverIconsInner>}
     * @memberof Cover
     */
    'icons': Array<CoverIconsInner>;
}
/**
 * 
 * @export
 * @interface CoverIconsInner
 */
export interface CoverIconsInner {
    /**
     * 
     * @type {string}
     * @memberof CoverIconsInner
     */
    'png': string;
    /**
     * 
     * @type {string}
     * @memberof CoverIconsInner
     */
    'svg'?: string;
}
/**
 * 
 * @export
 * @interface CoverResponse
 */
export interface CoverResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CoverResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Cover>}
     * @memberof CoverResponse
     */
    'items': Array<Cover>;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'view': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    'public': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateCollectionRequest
     */
    'parent'?: CollectionRef;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCollectionRequest
     */
    'cover': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {CreateCollectionResponseItem}
     * @memberof CreateCollectionResponse
     */
    'item': CreateCollectionResponseItem;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseItem
 */
export interface CreateCollectionResponseItem {
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof CreateCollectionResponseItem
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCollectionResponseItem
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'expanded': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    'creatorRef': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof CreateCollectionResponseItem
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'author': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    '__v': number;
}
/**
 * 
 * @export
 * @interface CreateRaindrop
 */
export interface CreateRaindrop {
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'lastUpdate': string;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindrop
     */
    'sort'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindrop
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof CreateRaindrop
     */
    'reminder': RaindropBaseReminder;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindrop
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof CreateRaindrop
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateRaindrop
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof CreateRaindrop
     */
    'highlights': Array<Highlight>;
    /**
     * 
     * @type {object}
     * @memberof CreateRaindrop
     */
    'pleaseParse'?: object;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequest
 */
export interface CreateRaindropRequest {
    /**
     * 
     * @type {object}
     * @memberof CreateRaindropRequest
     */
    'pleaseParse'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'lastUpdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropRequest
     */
    'important'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropRequest
     */
    'media'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'cover'?: string;
    /**
     * 
     * @type {CreateRaindropRequestCollection}
     * @memberof CreateRaindropRequest
     */
    'collection'?: CreateRaindropRequestCollection;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'excerpt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropRequestHighlightsInner>}
     * @memberof CreateRaindropRequest
     */
    'highlights'?: Array<CreateRaindropRequestHighlightsInner>;
    /**
     * 
     * @type {object}
     * @memberof CreateRaindropRequest
     */
    'reminder'?: object;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequestCollection
 */
export interface CreateRaindropRequestCollection {
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropRequestCollection
     */
    '$id': number;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequestHighlightsInner
 */
export interface CreateRaindropRequestHighlightsInner {
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequestHighlightsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequestHighlightsInner
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateRaindropResponse
 */
export interface CreateRaindropResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropResponse
     */
    'result': boolean;
    /**
     * 
     * @type {CreateRaindropResponseItem}
     * @memberof CreateRaindropResponse
     */
    'item': CreateRaindropResponseItem;
}
/**
 * 
 * @export
 * @interface CreateRaindropResponseItem
 */
export interface CreateRaindropResponseItem {
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    '__v': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateRaindropResponseItem
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'created': string;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    'creatorRef': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropResponseItem
     */
    'media': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof CreateRaindropResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface CreateRaindropsRequest
 */
export interface CreateRaindropsRequest {
    /**
     * 
     * @type {Array<CreateRaindrop>}
     * @memberof CreateRaindropsRequest
     */
    'items'?: Array<CreateRaindrop>;
}
/**
 * 
 * @export
 * @interface CreatorRef
 */
export interface CreatorRef {
    /**
     * 
     * @type {number}
     * @memberof CreatorRef
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreatorRef
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorRef
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof Filter
     */
    'broken': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof Filter
     */
    'duplicates': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof Filter
     */
    'important': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof Filter
     */
    'notag': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof Filter
     */
    'tags': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof Filter
     */
    'types': Array<FilterTagsInner>;
}
/**
 * 
 * @export
 * @interface FilterResponse
 */
export interface FilterResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FilterResponse
     */
    'result': boolean;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof FilterResponse
     */
    'broken': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof FilterResponse
     */
    'duplicates': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof FilterResponse
     */
    'important': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof FilterResponse
     */
    'notag': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof FilterResponse
     */
    'tags': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof FilterResponse
     */
    'types': Array<FilterTagsInner>;
}
/**
 * 
 * @export
 * @interface FilterTagsInner
 */
export interface FilterTagsInner {
    /**
     * 
     * @type {string}
     * @memberof FilterTagsInner
     */
    '_id': string;
    /**
     * 
     * @type {number}
     * @memberof FilterTagsInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'title': string;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof Folder
     */
    'folders': Array<Folder>;
    /**
     * 
     * @type {Array<Bookmark>}
     * @memberof Folder
     */
    'bookmarks': Array<Bookmark>;
}
/**
 * 
 * @export
 * @interface GetAllHighlightsResponse
 */
export interface GetAllHighlightsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetAllHighlightsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetAllHighlightsResponseItemsInner>}
     * @memberof GetAllHighlightsResponse
     */
    'items': Array<GetAllHighlightsResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetAllHighlightsResponseItemsInner
 */
export interface GetAllHighlightsResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'created': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'raindropRef': number;
}
/**
 * 
 * @export
 * @interface GetChildCollectionsResponse
 */
export interface GetChildCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetChildCollectionsResponseItemsInner>}
     * @memberof GetChildCollectionsResponse
     */
    'items': Array<GetChildCollectionsResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetChildCollectionsResponseItemsInner
 */
export interface GetChildCollectionsResponseItemsInner {
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'author': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'parent': CollectionRef;
}
/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetCollectionResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    'item'?: Collection;
}
/**
 * 
 * @export
 * @interface GetFeaturedCoversResponse
 */
export interface GetFeaturedCoversResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetFeaturedCoversResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetFeaturedCoversResponseItemsInner>}
     * @memberof GetFeaturedCoversResponse
     */
    'items': Array<GetFeaturedCoversResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetFeaturedCoversResponseItemsInner
 */
export interface GetFeaturedCoversResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'link'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'sort'?: number;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInnerIconsInner>}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'icons': Array<SearchCoversResponseItemsInnerIconsInner>;
}
/**
 * 
 * @export
 * @interface GetFiltersResponse
 */
export interface GetFiltersResponse {
    [key: string]: FilterTagsInner | any;

    /**
     * 
     * @type {boolean}
     * @memberof GetFiltersResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetFiltersResponse
     */
    'collectionId': number;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof GetFiltersResponse
     */
    'created': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof GetFiltersResponse
     */
    'tags': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof GetFiltersResponse
     */
    'types': Array<FilterTagsInner>;
}
/**
 * 
 * @export
 * @interface GetHighlightsInCollectionResponse
 */
export interface GetHighlightsInCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetHighlightsInCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetAllHighlightsResponseItemsInner>}
     * @memberof GetHighlightsInCollectionResponse
     */
    'items': Array<GetAllHighlightsResponseItemsInner>;
}
/**
 * @type GetOrRefreshToken200Response
 * @export
 */
export type GetOrRefreshToken200Response = TokenErrorResponse | TokenResponse;

/**
 * @type GetOrRefreshTokenRequest
 * @export
 */
export type GetOrRefreshTokenRequest = ObtainToken | RefreshToken;

/**
 * 
 * @export
 * @interface GetPublicUserByName200Response
 */
export interface GetPublicUserByName200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByName200Response
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPublicUserByName200Response
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'email_MD5'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'fullName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByName200Response
     */
    'pro'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'registered'?: string;
}
/**
 * 
 * @export
 * @interface GetRootCollectionsResponse
 */
export interface GetRootCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetRootCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Collection>}
     * @memberof GetRootCollectionsResponse
     */
    'items': Array<Collection>;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponse
 */
export interface GetSystemCollectionStatsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetSystemCollectionStatsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetSystemCollectionStatsResponseItemsInner>}
     * @memberof GetSystemCollectionStatsResponse
     */
    'items': Array<GetSystemCollectionStatsResponseItemsInner>;
    /**
     * 
     * @type {GetSystemCollectionStatsResponseMeta}
     * @memberof GetSystemCollectionStatsResponse
     */
    'meta': GetSystemCollectionStatsResponseMeta;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponseItemsInner
 */
export interface GetSystemCollectionStatsResponseItemsInner {
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseItemsInner
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseItemsInner
     */
    '_id': number;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponseMeta
 */
export interface GetSystemCollectionStatsResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    '_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    'changedBookmarksDate': string;
}
/**
 * 
 * @export
 * @interface GetTagsInCollection200Response
 */
export interface GetTagsInCollection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetTagsInCollection200Response
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetTagsInCollection200ResponseAllOfItemsInner>}
     * @memberof GetTagsInCollection200Response
     */
    'items'?: Array<GetTagsInCollection200ResponseAllOfItemsInner>;
}
/**
 * 
 * @export
 * @interface GetTagsInCollection200ResponseAllOfItemsInner
 */
export interface GetTagsInCollection200ResponseAllOfItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetTagsInCollection200ResponseAllOfItemsInner
     */
    '_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTagsInCollection200ResponseAllOfItemsInner
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'hidden': boolean;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'sort': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Group
     */
    'collections': Array<number>;
}
/**
 * 
 * @export
 * @interface Highlight
 */
export interface Highlight {
    /**
     * 
     * @type {string}
     * @memberof Highlight
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Highlight
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof Highlight
     */
    'color': HighlightColorEnum;
    /**
     * 
     * @type {string}
     * @memberof Highlight
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof Highlight
     */
    'created': string;
}

export const HighlightColorEnum = {
    Blue: 'blue',
    Brown: 'brown',
    Cyan: 'cyan',
    Gray: 'gray',
    Green: 'green',
    Indigo: 'indigo',
    Orange: 'orange',
    Pink: 'pink',
    Purple: 'purple',
    Red: 'red',
    Teal: 'teal',
    Yellow: 'yellow'
} as const;

export type HighlightColorEnum = typeof HighlightColorEnum[keyof typeof HighlightColorEnum];

/**
 * 
 * @export
 * @interface HighlightItem
 */
export interface HighlightItem {
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'color': HighlightItemColorEnum;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'created': string;
    /**
     * 
     * @type {number}
     * @memberof HighlightItem
     */
    'raindropRef': number;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HighlightItem
     */
    'tags': Array<string>;
}

export const HighlightItemColorEnum = {
    Blue: 'blue',
    Brown: 'brown',
    Cyan: 'cyan',
    Gray: 'gray',
    Green: 'green',
    Indigo: 'indigo',
    Orange: 'orange',
    Pink: 'pink',
    Purple: 'purple',
    Red: 'red',
    Teal: 'teal',
    Yellow: 'yellow'
} as const;

export type HighlightItemColorEnum = typeof HighlightItemColorEnum[keyof typeof HighlightItemColorEnum];

/**
 * 
 * @export
 * @interface HighlightResponse
 */
export interface HighlightResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HighlightResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<HighlightItem>}
     * @memberof HighlightResponse
     */
    'items': Array<HighlightItem>;
}
/**
 * 
 * @export
 * @interface ImportFileResponse
 */
export interface ImportFileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ImportFileResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof ImportFileResponse
     */
    'items': Array<Folder>;
}
/**
 * 
 * @export
 * @interface MergeCollectionsRequest
 */
export interface MergeCollectionsRequest {
    /**
     * 
     * @type {number}
     * @memberof MergeCollectionsRequest
     */
    'to'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof MergeCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface MergeCollectionsResponse
 */
export interface MergeCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MergeCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof MergeCollectionsResponse
     */
    'modified': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof MergeCollectionsResponse
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface ObtainToken
 */
export interface ObtainToken {
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'grant_type': ObtainTokenGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'redirect_uri': string;
}

export const ObtainTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code'
} as const;

export type ObtainTokenGrantTypeEnum = typeof ObtainTokenGrantTypeEnum[keyof typeof ObtainTokenGrantTypeEnum];

/**
 * @type ParseURL200Response
 * @export
 */
export type ParseURL200Response = ParseUrlErrorResponse | ParseUrlResponse;

/**
 * 
 * @export
 * @interface ParseUrlErrorResponse
 */
export interface ParseUrlErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ParseUrlErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParseUrlErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ParseUrlErrorResponse
     */
    'errorMessage': string;
    /**
     * 
     * @type {UrlParse}
     * @memberof ParseUrlErrorResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface ParseUrlResponse
 */
export interface ParseUrlResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ParseUrlResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UrlParse}
     * @memberof ParseUrlResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface Raindrop
 */
export interface Raindrop {
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'lastUpdate': string;
    /**
     * 
     * @type {number}
     * @memberof Raindrop
     */
    'sort'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Raindrop
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof Raindrop
     */
    'reminder': RaindropBaseReminder;
    /**
     * 
     * @type {Array<string>}
     * @memberof Raindrop
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof Raindrop
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof Raindrop
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof Raindrop
     */
    'highlights': Array<Highlight>;
    /**
     * 
     * @type {number}
     * @memberof Raindrop
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'domain': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof Raindrop
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {UserRef}
     * @memberof Raindrop
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof Raindrop
     */
    'broken': boolean;
    /**
     * 
     * @type {RaindropAllOfCache}
     * @memberof Raindrop
     */
    'cache': RaindropAllOfCache;
    /**
     * 
     * @type {RaindropAllOfFile}
     * @memberof Raindrop
     */
    'file'?: RaindropAllOfFile;
}
/**
 * 
 * @export
 * @interface RaindropAllOfCache
 */
export interface RaindropAllOfCache {
    /**
     * 
     * @type {string}
     * @memberof RaindropAllOfCache
     */
    'status': RaindropAllOfCacheStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof RaindropAllOfCache
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof RaindropAllOfCache
     */
    'created': string;
}

export const RaindropAllOfCacheStatusEnum = {
    Ready: 'ready',
    Retry: 'retry',
    Failed: 'failed',
    InvalidMinusOrigin: 'invalid-origin',
    InvalidMinusTimeout: 'invalid-timeout',
    InvalidMinusSize: 'invalid-size'
} as const;

export type RaindropAllOfCacheStatusEnum = typeof RaindropAllOfCacheStatusEnum[keyof typeof RaindropAllOfCacheStatusEnum];

/**
 * 
 * @export
 * @interface RaindropAllOfFile
 */
export interface RaindropAllOfFile {
    /**
     * 
     * @type {string}
     * @memberof RaindropAllOfFile
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RaindropAllOfFile
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof RaindropAllOfFile
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RaindropBase
 */
export interface RaindropBase {
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'lastUpdate': string;
    /**
     * 
     * @type {number}
     * @memberof RaindropBase
     */
    'sort'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RaindropBase
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof RaindropBase
     */
    'reminder': RaindropBaseReminder;
    /**
     * 
     * @type {Array<string>}
     * @memberof RaindropBase
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof RaindropBase
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof RaindropBase
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof RaindropBase
     */
    'highlights': Array<Highlight>;
}
/**
 * 
 * @export
 * @interface RaindropBaseMediaInner
 */
export interface RaindropBaseMediaInner {
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseMediaInner
     */
    'type': RaindropBaseMediaInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseMediaInner
     */
    'link': string;
}

export const RaindropBaseMediaInnerTypeEnum = {
    Link: 'link',
    Image: 'image'
} as const;

export type RaindropBaseMediaInnerTypeEnum = typeof RaindropBaseMediaInnerTypeEnum[keyof typeof RaindropBaseMediaInnerTypeEnum];

/**
 * 
 * @export
 * @interface RaindropBaseReminder
 */
export interface RaindropBaseReminder {
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseReminder
     */
    'date': string | null;
}
/**
 * 
 * @export
 * @interface RaindropResponseMany
 */
export interface RaindropResponseMany {
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseMany
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Raindrop>}
     * @memberof RaindropResponseMany
     */
    'items': Array<Raindrop>;
    /**
     * 
     * @type {number}
     * @memberof RaindropResponseMany
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof RaindropResponseMany
     */
    'collectionId': number;
}
/**
 * 
 * @export
 * @interface RaindropResponseOne
 */
export interface RaindropResponseOne {
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseOne
     */
    'result': boolean;
    /**
     * 
     * @type {Raindrop}
     * @memberof RaindropResponseOne
     */
    'item': Raindrop;
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseOne
     */
    'author': boolean;
}
/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'grant_type': RefreshTokenGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'refresh_token': string;
}

export const RefreshTokenGrantTypeEnum = {
    RefreshToken: 'refresh_token'
} as const;

export type RefreshTokenGrantTypeEnum = typeof RefreshTokenGrantTypeEnum[keyof typeof RefreshTokenGrantTypeEnum];

/**
 * 
 * @export
 * @interface RemoveAllEmptyCollectionsResponse
 */
export interface RemoveAllEmptyCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveAllEmptyCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveAllEmptyCollectionsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface RemoveCollectionsRequest
 */
export interface RemoveCollectionsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveCollectionsResponse
 */
export interface RemoveCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveCollectionsResponse
     */
    'modified': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveCollectionsResponse
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveRaindrops200Response
 */
export interface RemoveRaindrops200Response {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveRaindrops200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindrops200Response
     */
    'modified'?: number;
}
/**
 * 
 * @export
 * @interface RemoveRaindropsRequest
 */
export interface RemoveRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveRaindropsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveTagsFromCollectionRequest
 */
export interface RemoveTagsFromCollectionRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveTagsFromCollectionRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RenameOrMergeTagsRequest
 */
export interface RenameOrMergeTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof RenameOrMergeTagsRequest
     */
    'replace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RenameOrMergeTagsRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReorderAllCollectionsRequest
 */
export interface ReorderAllCollectionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReorderAllCollectionsRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReorderAllCollectionsRequest
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {boolean}
     * @memberof Response
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Member: 'member',
    Viewer: 'viewer'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface SearchCoversResponse
 */
export interface SearchCoversResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SearchCoversResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInner>}
     * @memberof SearchCoversResponse
     */
    'items': Array<SearchCoversResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface SearchCoversResponseItemsInner
 */
export interface SearchCoversResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof SearchCoversResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInnerIconsInner>}
     * @memberof SearchCoversResponseItemsInner
     */
    'icons': Array<SearchCoversResponseItemsInnerIconsInner>;
}
/**
 * 
 * @export
 * @interface SearchCoversResponseItemsInnerIconsInner
 */
export interface SearchCoversResponseItemsInnerIconsInner {
    /**
     * 
     * @type {string}
     * @memberof SearchCoversResponseItemsInnerIconsInner
     */
    'png': string;
}
/**
 * 
 * @export
 * @interface ShareCollection200Response
 */
export interface ShareCollection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ShareCollection200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareCollection200Response
     */
    'emails'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ShareCollectionRequest
 */
export interface ShareCollectionRequest {
    /**
     * 
     * @type {Role}
     * @memberof ShareCollectionRequest
     */
    'role'?: Role;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareCollectionRequest
     */
    'emails'?: Array<string>;
}


/**
 * 
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SimpleResponse
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @interface StatResponse
 */
export interface StatResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StatResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<StatResponseAllOfItems>}
     * @memberof StatResponse
     */
    'items': Array<StatResponseAllOfItems>;
    /**
     * 
     * @type {StatResponseAllOfMeta}
     * @memberof StatResponse
     */
    'meta': StatResponseAllOfMeta;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfItems
 */
export interface StatResponseAllOfItems {
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfItems
     */
    '_id': number;
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfItems
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfMeta
 */
export interface StatResponseAllOfMeta {
    /**
     * 
     * @type {boolean}
     * @memberof StatResponseAllOfMeta
     */
    'pro': boolean;
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfMeta
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof StatResponseAllOfMeta
     */
    'changedBookmarksDate': string;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof StatResponseAllOfMeta
     */
    'duplicates': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof StatResponseAllOfMeta
     */
    'broken': StatResponseAllOfMetaDuplicates;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfMetaDuplicates
 */
export interface StatResponseAllOfMetaDuplicates {
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfMetaDuplicates
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Suggest
 */
export interface Suggest {
    /**
     * 
     * @type {Array<CollectionRef>}
     * @memberof Suggest
     */
    'collections': Array<CollectionRef>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Suggest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface SuggestForNewBookmarkRequest
 */
export interface SuggestForNewBookmarkRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestForNewBookmarkRequest
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface SuggestResponse
 */
export interface SuggestResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuggestResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Suggest}
     * @memberof SuggestResponse
     */
    'item': Suggest;
}
/**
 * 
 * @export
 * @interface TokenErrorResponse
 */
export interface TokenErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenErrorResponse
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof TokenErrorResponse
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     * @deprecated
     */
    'expires'?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type': TokenResponseTokenTypeEnum;
}

export const TokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type TokenResponseTokenTypeEnum = typeof TokenResponseTokenTypeEnum[keyof typeof TokenResponseTokenTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCollectionRequest
 */
export interface UpdateCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'view'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCollectionRequest
     */
    'sort'?: number;
    /**
     * Collection and raindrops that it contains will be accessible without authentication?
     * @type {boolean}
     * @memberof UpdateCollectionRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UpdateCollectionRequest
     */
    'parent'?: CollectionRef;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCollectionRequest
     */
    'cover'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCollectionRequest
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateCollectionResponse
 */
export interface UpdateCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Collection}
     * @memberof UpdateCollectionResponse
     */
    'item': Collection;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserRequest
 */
export interface UpdateCurrentUserRequest {
    /**
     * 
     * @type {Array<Group>}
     * @memberof UpdateCurrentUserRequest
     */
    'groups'?: Array<Group>;
    /**
     * 
     * @type {UserConfig}
     * @memberof UpdateCurrentUserRequest
     */
    'config'?: UserConfig;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'newpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'oldpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsRequest
 */
export interface UpdateRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateRaindropsRequest
     */
    'ids'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRaindropsRequest
     */
    'important'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'media'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropsRequest
     */
    'cover'?: string;
    /**
     * 
     * @type {UpdateRaindropsRequestCollection}
     * @memberof UpdateRaindropsRequest
     */
    'collection'?: UpdateRaindropsRequestCollection;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsRequestCollection
 */
export interface UpdateRaindropsRequestCollection {
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropsRequestCollection
     */
    '$id'?: number;
}
/**
 * 
 * @export
 * @interface UploadCollectionCoverResponse
 */
export interface UploadCollectionCoverResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UploadCollectionCoverResponseItem}
     * @memberof UploadCollectionCoverResponse
     */
    'item': UploadCollectionCoverResponseItem;
}
/**
 * 
 * @export
 * @interface UploadCollectionCoverResponseItem
 */
export interface UploadCollectionCoverResponseItem {
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof UploadCollectionCoverResponseItem
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UploadCollectionCoverResponseItem
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof UploadCollectionCoverResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof UploadCollectionCoverResponseItem
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'author': boolean;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    '__v': number;
}
/**
 * 
 * @export
 * @interface UrlParse
 */
export interface UrlParse {
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'excerpt': string;
    /**
     * 
     * @type {Array<UrlParseMediaInner>}
     * @memberof UrlParse
     */
    'media': Array<UrlParseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'type': string;
    /**
     * 
     * @type {UrlParseMeta}
     * @memberof UrlParse
     */
    'meta': UrlParseMeta;
}
/**
 * 
 * @export
 * @interface UrlParseErrorResponse
 */
export interface UrlParseErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof UrlParseErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseErrorResponse
     */
    'errorMessage': string;
    /**
     * 
     * @type {UrlParse}
     * @memberof UrlParseErrorResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface UrlParseMediaInner
 */
export interface UrlParseMediaInner {
    /**
     * 
     * @type {string}
     * @memberof UrlParseMediaInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMediaInner
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface UrlParseMeta
 */
export interface UrlParseMeta {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseMeta
     */
    'possibleArticle': boolean;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMeta
     */
    'canonical': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMeta
     */
    'site': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UrlParseMeta
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UrlParseResponse
 */
export interface UrlParseResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UrlParse}
     * @memberof UrlParseResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    '_id': number;
    /**
     * 
     * @type {UserConfig}
     * @memberof User
     */
    'config': UserConfig;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'dropbox'?: UserDropbox;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email_MD5'?: string;
    /**
     * 
     * @type {UserFiles}
     * @memberof User
     */
    'files': UserFiles;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'gdrive'?: UserDropbox;
    /**
     * 
     * @type {Array<Group>}
     * @memberof User
     */
    'groups': Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'proExpire'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'registered': string;
    /**
     * 
     * @type {UserTfa}
     * @memberof User
     */
    'tfa'?: UserTfa;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastAction'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastVisit'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastUpdate'?: string;
}
/**
 * 
 * @export
 * @interface UserConfig
 */
export interface UserConfig {
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'broken_level': string;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'font_color'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'font_size': number;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'lang'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'last_collection': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'raindrops_buttons'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'raindrops_hide'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'raindrops_search_by_score'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'raindrops_search_incollection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'raindrops_sort': string;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'default_collection_view'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'nested_view_legacy'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'add_default_collection'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'acknowledge'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'ai_suggestions'?: boolean;
}
/**
 * 
 * @export
 * @interface UserDropbox
 */
export interface UserDropbox {
    /**
     * 
     * @type {boolean}
     * @memberof UserDropbox
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserFiles
 */
export interface UserFiles {
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'used': number;
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UserFiles
     */
    'lastCheckPoint': string;
}
/**
 * 
 * @export
 * @interface UserRef
 */
export interface UserRef {
    /**
     * 
     * @type {number}
     * @memberof UserRef
     */
    '$id': number;
    /**
     * 
     * @type {string}
     * @memberof UserRef
     */
    '$ref': string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'result': boolean;
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface UserTfa
 */
export interface UserTfa {
    /**
     * 
     * @type {boolean}
     * @memberof UserTfa
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const View = {
    List: 'list',
    Simple: 'simple',
    Grid: 'grid',
    Masonry: 'masonry'
} as const;

export type View = typeof View[keyof typeof View];



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorize', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorize', 'clientId', clientId)
            const localVarPath = `/v1/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken: async (getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/oauth/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrRefreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrRefreshToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrRefreshToken(getOrRefreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getOrRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(redirectUri: string, clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorize(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: any): AxiosPromise<GetOrRefreshToken200Response> {
            return localVarFp.getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authorize(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authorize(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptInvitation', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/join`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel: async (userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeCollaboratorAccessLevelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (createCollectionRequest?: CreateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator: async (userId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCollaborator', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollaborator', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection/-99`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/childrens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollaborators', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/covers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections: async (mergeCollectionsRequest?: MergeCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/clean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections: async (removeCollectionsRequest?: RemoveCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections: async (reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderAllCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers: async (text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchCovers', 'text', text)
            const localVarPath = `/rest/v1/collections/covers/{text}`
                .replace(`{${"text"}}`, encodeURIComponent(String(text)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection: async (id: number, shareCollectionRequest?: ShareCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shareCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unshareOrLeaveCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (id: number, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover: async (id: number, cover?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadCollectionCover', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvitation(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptInvitation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvitation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.acceptInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.changeCollaboratorAccessLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(createCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.createCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollaborator(userId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollaborator(userId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.deleteCollaborator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.emptyTrash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChildCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChildCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getChildCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborators(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborators(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getCollaborators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedCovers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeaturedCoversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedCovers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getFeaturedCovers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRootCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getRootCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemCollectionStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getSystemCollectionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MergeCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeCollections(mergeCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.mergeCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllEmptyCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveAllEmptyCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllEmptyCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeAllEmptyCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollections(removeCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderAllCollections(reorderAllCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.reorderAllCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCovers(text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCovers(text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.searchCovers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareCollection(id, shareCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.shareCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareOrLeaveCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareOrLeaveCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.unshareOrLeaveCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(id, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.updateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCollectionCover(id: number, cover?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadCollectionCoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCollectionCover(id, cover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.uploadCollectionCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(id: number, options?: any): AxiosPromise<AcceptInvitation200Response> {
            return localVarFp.acceptInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: any): AxiosPromise<void> {
            return localVarFp.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(createCollectionRequest?: CreateCollectionRequest, options?: any): AxiosPromise<CreateCollectionResponse> {
            return localVarFp.createCollection(createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator(userId: number, id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.deleteCollaborator(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections(options?: any): AxiosPromise<GetChildCollectionsResponse> {
            return localVarFp.getChildCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getCollaborators(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: number, options?: any): AxiosPromise<GetCollectionResponse> {
            return localVarFp.getCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers(options?: any): AxiosPromise<GetFeaturedCoversResponse> {
            return localVarFp.getFeaturedCovers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections(options?: any): AxiosPromise<GetRootCollectionsResponse> {
            return localVarFp.getRootCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<GetSystemCollectionStatsResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: any): AxiosPromise<MergeCollectionsResponse> {
            return localVarFp.mergeCollections(mergeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections(options?: any): AxiosPromise<RemoveAllEmptyCollectionsResponse> {
            return localVarFp.removeAllEmptyCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.removeCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: any): AxiosPromise<RemoveCollectionsResponse> {
            return localVarFp.removeCollections(removeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers(text: string, options?: any): AxiosPromise<CoverResponse> {
            return localVarFp.searchCovers(text, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: any): AxiosPromise<ShareCollection200Response> {
            return localVarFp.shareCollection(id, shareCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.unshareOrLeaveCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: any): AxiosPromise<UpdateCollectionResponse> {
            return localVarFp.updateCollection(id, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover(id: number, cover?: File, options?: any): AxiosPromise<UploadCollectionCoverResponse> {
            return localVarFp.uploadCollectionCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public acceptInvitation(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).acceptInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).createCollection(createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteCollaborator(userId: number, id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteCollaborator(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public emptyTrash(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getChildCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getChildCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollaborators(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollaborators(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getFeaturedCovers(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getFeaturedCovers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getRootCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getRootCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getSystemCollectionStats(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).mergeCollections(mergeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeAllEmptyCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeAllEmptyCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollections(removeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public searchCovers(text: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).searchCovers(text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {ShareCollectionRequest} [shareCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).shareCollection(id, shareCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public unshareOrLeaveCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).unshareOrLeaveCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).updateCollection(id, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {File} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public uploadCollectionCover(id: number, cover?: File, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).uploadCollectionCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getFilters', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/filters/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagsSort !== undefined) {
                localVarQueryParameter['tagsSort'] = tagsSort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(collectionId, tagsSort, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilterApi.getFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterApiFp(configuration)
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: any): AxiosPromise<FilterResponse> {
            return localVarFp.getFilters(collectionId, tagsSort, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @param {number} collectionId 
     * @param {GetFiltersTagsSortEnum} [tagsSort] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: RawAxiosRequestConfig) {
        return FilterApiFp(this.configuration).getFilters(collectionId, tagsSort, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFiltersTagsSortEnum = {
    MinusCount: '-count',
    Id: '_id'
} as const;
export type GetFiltersTagsSortEnum = typeof GetFiltersTagsSortEnum[keyof typeof GetFiltersTagsSortEnum];


/**
 * HighlightApi - axios parameter creator
 * @export
 */
export const HighlightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights: async (page?: number, perpage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/highlights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection: async (collectionId: number, page?: number, perpage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getHighlightsInCollection', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/highlights/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, createRaindrop?: CreateRaindrop, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindrop, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HighlightApi - functional programming interface
 * @export
 */
export const HighlightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HighlightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllHighlights(page?: number, perpage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HighlightResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllHighlights(page, perpage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getAllHighlights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HighlightResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightsInCollection(collectionId, page, perpage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getHighlightsInCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, createRaindrop, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.updateRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HighlightApi - factory interface
 * @export
 */
export const HighlightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HighlightApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights(page?: number, perpage?: number, options?: any): AxiosPromise<HighlightResponse> {
            return localVarFp.getAllHighlights(page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: any): AxiosPromise<HighlightResponse> {
            return localVarFp.getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.updateRaindrop(id, createRaindrop, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HighlightApi - object-oriented interface
 * @export
 * @class HighlightApi
 * @extends {BaseAPI}
 */
export class HighlightApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [perpage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getAllHighlights(page?: number, perpage?: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getAllHighlights(page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {number} [page] 
     * @param {number} [perpage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateRaindrop} [createRaindrop] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).updateRaindrop(id, createRaindrop, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist: async (checkURLsExistRequest?: CheckURLsExistRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkURLsExistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile: async (_import?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (_import !== undefined) { 
                localVarFormParams.append('import', _import as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL: async (url?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckURLsExist200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkURLsExist(checkURLsExistRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.checkURLsExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importHTMLBookmarkFile(_import?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importHTMLBookmarkFile(_import, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importHTMLBookmarkFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseURL(url?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseURL200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseURL(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.parseURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: any): AxiosPromise<CheckURLsExist200Response> {
            return localVarFp.checkURLsExist(checkURLsExistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile(_import?: File, options?: any): AxiosPromise<ImportFileResponse> {
            return localVarFp.importHTMLBookmarkFile(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL(url?: string, options?: any): AxiosPromise<ParseURL200Response> {
            return localVarFp.parseURL(url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * 
     * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).checkURLsExist(checkURLsExistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [_import] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importHTMLBookmarkFile(_import?: File, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importHTMLBookmarkFile(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [url] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public parseURL(url?: string, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).parseURL(url, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RaindropApi - axios parameter creator
 * @export
 */
export const RaindropApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop: async (createRaindropRequest?: CreateRaindropRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindropRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops: async (createRaindropsRequest?: CreateRaindropsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermanentCopy', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cache`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops: async (collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops: async (collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('removeRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('suggestForExistingBookmark', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/suggest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark: async (suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestForNewBookmarkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, createRaindrop?: CreateRaindrop, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindrop, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops: async (collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: File, collectionId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (collectionId !== undefined) { 
                localVarFormParams.append('collectionId', collectionId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover: async (id: number, cover?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadRaindropCover', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaindropApi - functional programming interface
 * @export
 */
export const RaindropApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaindropApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrop(createRaindropRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.createRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrops(createRaindropsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.createRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermanentCopy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermanentCopy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getPermanentCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrops(collectionId, sort, perpage, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.removeRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveRaindrops200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrops(collectionId, search, removeRaindropsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.removeRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForExistingBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForExistingBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.suggestForExistingBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForNewBookmark(suggestForNewBookmarkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.suggestForNewBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, createRaindrop, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.updateRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrops(collectionId, updateRaindropsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.updateRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: File, collectionId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRaindropCover(id: number, cover?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRaindropCover(id, cover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.uploadRaindropCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RaindropApi - factory interface
 * @export
 */
export const RaindropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaindropApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: any): AxiosPromise<CreateRaindropResponse> {
            return localVarFp.createRaindrop(createRaindropRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: any): AxiosPromise<RaindropResponseMany> {
            return localVarFp.createRaindrops(createRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getPermanentCopy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: any): AxiosPromise<RaindropResponseMany> {
            return localVarFp.getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.removeRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: any): AxiosPromise<RemoveRaindrops200Response> {
            return localVarFp.removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark(id: number, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.suggestForExistingBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.updateRaindrop(id, createRaindrop, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: File, collectionId?: number, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.uploadFile(file, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover(id: number, cover?: File, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.uploadRaindropCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaindropApi - object-oriented interface
 * @export
 * @class RaindropApi
 * @extends {BaseAPI}
 */
export class RaindropApi extends BaseAPI {
    /**
     * 
     * @param {CreateRaindropRequest} [createRaindropRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrop(createRaindropRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateRaindropsRequest} [createRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrops(createRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getPermanentCopy(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getPermanentCopy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {string} [sort] 
     * @param {number} [perpage] 
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {string} [search] 
     * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForExistingBookmark(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForExistingBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateRaindrop} [createRaindrop] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrop(id, createRaindrop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [file] 
     * @param {number} [collectionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadFile(file?: File, collectionId?: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadFile(file, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {File} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadRaindropCover(id: number, cover?: File, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadRaindropCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection: async (collectionId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection: async (collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeTagsFromCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags: async (collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameOrMergeTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsInCollection(collectionId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTagsInCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagsInCollection(collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.getTagsInCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.removeTagsFromCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.renameOrMergeTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection(collectionId?: number, options?: any): AxiosPromise<GetTagsInCollection200Response> {
            return localVarFp.getTagsInCollection(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {number} [collectionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagsInCollection(collectionId?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagsInCollection(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [collectionId] 
     * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [collectionId] 
     * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider: async (provider: ConnectSocialNetworkProviderProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider: async (provider: DisconnectSocialNetworkProviderProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('disconnectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}/revoke`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName: async (name: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPublicUserByName', 'name', name)
            const localVarPath = `/rest/v1/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (updateCurrentUserRequest?: UpdateCurrentUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCurrentUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectSocialNetworkProvider(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.connectSocialNetworkProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectSocialNetworkProvider(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.disconnectSocialNetworkProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUserByName(name: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicUserByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUserByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getPublicUserByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemCollectionStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getSystemCollectionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(updateCurrentUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.connectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.disconnectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName(name: number, options?: any): AxiosPromise<GetPublicUserByName200Response> {
            return localVarFp.getPublicUserByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<GetSystemCollectionStatsResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {ConnectSocialNetworkProviderProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).connectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).disconnectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUserByName(name: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getPublicUserByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSystemCollectionStats(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type ConnectSocialNetworkProviderProviderEnum = typeof ConnectSocialNetworkProviderProviderEnum[keyof typeof ConnectSocialNetworkProviderProviderEnum];
/**
 * @export
 */
export const DisconnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type DisconnectSocialNetworkProviderProviderEnum = typeof DisconnectSocialNetworkProviderProviderEnum[keyof typeof DisconnectSocialNetworkProviderProviderEnum];


