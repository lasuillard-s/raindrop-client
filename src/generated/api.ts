/* tslint:disable */
/* eslint-disable */
/**
 * Raindrop API (Unofficial)
 * **UNOFFICIAL** OpenAPI specification of Raindrop API.  This OpenAPI spec has been made by hand with reference to official documentation because it is not provided by Raindrop.io.  Because official documentation not maintained well, there are very (highly) likely to have mismatch in schemas. As we can\'t inspect and address all issues, schema being updated as we find issues.  Any contributions are welcome. Bug report, schema update, adding descriptions or functions, please don\'t hesitate to create an issue.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptInvitation200Response
 */
export interface AcceptInvitation200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptInvitation200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {Role}
     * @memberof AcceptInvitation200Response
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface ChangeCollaboratorAccessLevelRequest
 */
export interface ChangeCollaboratorAccessLevelRequest {
    /**
     * 
     * @type {Role}
     * @memberof ChangeCollaboratorAccessLevelRequest
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface CheckURLsExistRequest
 */
export interface CheckURLsExistRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckURLsExistRequest
     */
    'urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CheckURLsExistResponse
 */
export interface CheckURLsExistResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CheckURLsExistResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CheckURLsExistResponse
     */
    'ids': Array<number>;
    /**
     * 
     * @type {Array<CheckURLsExistResponseDuplicatesInner>}
     * @memberof CheckURLsExistResponse
     */
    'duplicates': Array<CheckURLsExistResponseDuplicatesInner>;
    /**
     * 
     * @type {number}
     * @memberof CheckURLsExistResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CheckURLsExistResponseDuplicatesInner
 */
export interface CheckURLsExistResponseDuplicatesInner {
    /**
     * 
     * @type {number}
     * @memberof CheckURLsExistResponseDuplicatesInner
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CheckURLsExistResponseDuplicatesInner
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof Collection
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Collection
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof Collection
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof Collection
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof Collection
     */
    'author': boolean;
    /**
     * 
     * @type {object}
     * @memberof Collection
     */
    'parent': object | null;
}
/**
 * 
 * @export
 * @interface CollectionAccess
 */
export interface CollectionAccess {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAccess
     */
    'draggable': boolean;
    /**
     * 
     * @type {number}
     * @memberof CollectionAccess
     */
    'for': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionAccess
     */
    'level': number;
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAccess
     */
    'root': boolean;
}
/**
 * 
 * @export
 * @interface CollectionRef
 */
export interface CollectionRef {
    /**
     * 
     * @type {string}
     * @memberof CollectionRef
     */
    '$ref': CollectionRefRefEnum;
    /**
     * 
     * @type {number}
     * @memberof CollectionRef
     */
    '$id': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionRef
     */
    'oid'?: number;
}

export const CollectionRefRefEnum = {
    Collections: 'collections'
} as const;

export type CollectionRefRefEnum = typeof CollectionRefRefEnum[keyof typeof CollectionRefRefEnum];

/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'view': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    'public': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateCollectionRequest
     */
    'parent'?: CollectionRef | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCollectionRequest
     */
    'cover': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {CreateCollectionResponseItem}
     * @memberof CreateCollectionResponse
     */
    'item': CreateCollectionResponseItem;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseItem
 */
export interface CreateCollectionResponseItem {
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof CreateCollectionResponseItem
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCollectionResponseItem
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof CreateCollectionResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionResponseItem
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof CreateCollectionResponseItem
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollectionResponseItem
     */
    'author': boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionResponseItem
     */
    'parent': object | null;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionResponseItem
     */
    '__v': number;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequest
 */
export interface CreateRaindropRequest {
    /**
     * 
     * @type {object}
     * @memberof CreateRaindropRequest
     */
    'pleaseParse'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'lastUpdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropRequest
     */
    'important'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<ParseURLResponseItemMediaInner>}
     * @memberof CreateRaindropRequest
     */
    'media'?: Array<ParseURLResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'cover'?: string;
    /**
     * 
     * @type {CreateRaindropRequestCollection}
     * @memberof CreateRaindropRequest
     */
    'collection'?: CreateRaindropRequestCollection;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'excerpt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequest
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropRequestHighlightsInner>}
     * @memberof CreateRaindropRequest
     */
    'highlights'?: Array<CreateRaindropRequestHighlightsInner>;
    /**
     * 
     * @type {object}
     * @memberof CreateRaindropRequest
     */
    'reminder'?: object;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequestCollection
 */
export interface CreateRaindropRequestCollection {
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropRequestCollection
     */
    '$id': number;
}
/**
 * 
 * @export
 * @interface CreateRaindropRequestHighlightsInner
 */
export interface CreateRaindropRequestHighlightsInner {
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequestHighlightsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropRequestHighlightsInner
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateRaindropResponse
 */
export interface CreateRaindropResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropResponse
     */
    'result': boolean;
    /**
     * 
     * @type {CreateRaindropResponseItem}
     * @memberof CreateRaindropResponse
     */
    'item': CreateRaindropResponseItem;
}
/**
 * 
 * @export
 * @interface CreateRaindropResponseItem
 */
export interface CreateRaindropResponseItem {
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    '__v': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateRaindropResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof CreateRaindropResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof CreateRaindropResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateRaindropResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRaindropResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof CreateRaindropResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface CreateRaindropResponseItemMediaInner
 */
export interface CreateRaindropResponseItemMediaInner {
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItemMediaInner
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindropResponseItemMediaInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CreateRaindropsResponse
 */
export interface CreateRaindropsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateRaindropsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<UpdateRaindropResponseItem>}
     * @memberof CreateRaindropsResponse
     */
    'items': Array<UpdateRaindropResponseItem>;
}
/**
 * @type CreatorRef
 * @export
 */
export type CreatorRef = CreatorRefOneOf | number;

/**
 * 
 * @export
 * @interface CreatorRefOneOf
 */
export interface CreatorRefOneOf {
    /**
     * 
     * @type {number}
     * @memberof CreatorRefOneOf
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreatorRefOneOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorRefOneOf
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorRefOneOf
     */
    'avatar'?: string;
}
/**
 * 
 * @export
 * @interface GetAllHighlightsResponse
 */
export interface GetAllHighlightsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetAllHighlightsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetAllHighlightsResponseItemsInner>}
     * @memberof GetAllHighlightsResponse
     */
    'items': Array<GetAllHighlightsResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetAllHighlightsResponseItemsInner
 */
export interface GetAllHighlightsResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'created': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllHighlightsResponseItemsInner
     */
    'raindropRef': number;
}
/**
 * 
 * @export
 * @interface GetChildCollectionsResponse
 */
export interface GetChildCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetChildCollectionsResponseItemsInner>}
     * @memberof GetChildCollectionsResponse
     */
    'items': Array<GetChildCollectionsResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetChildCollectionsResponseItemsInner
 */
export interface GetChildCollectionsResponseItemsInner {
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'author': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof GetChildCollectionsResponseItemsInner
     */
    'parent': CollectionRef | null;
}
/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetCollectionResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    'item'?: Collection;
}
/**
 * 
 * @export
 * @interface GetCurrentUserResponse
 */
export interface GetCurrentUserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetCurrentUserResponse
     */
    'result': boolean;
    /**
     * 
     * @type {User}
     * @memberof GetCurrentUserResponse
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface GetFeaturedCoversResponse
 */
export interface GetFeaturedCoversResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetFeaturedCoversResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetFeaturedCoversResponseItemsInner>}
     * @memberof GetFeaturedCoversResponse
     */
    'items': Array<GetFeaturedCoversResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetFeaturedCoversResponseItemsInner
 */
export interface GetFeaturedCoversResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'link'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'sort'?: number;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInnerIconsInner>}
     * @memberof GetFeaturedCoversResponseItemsInner
     */
    'icons': Array<SearchCoversResponseItemsInnerIconsInner>;
}
/**
 * 
 * @export
 * @interface GetFiltersResponse
 */
export interface GetFiltersResponse {
    [key: string]: GetFiltersResponseCreatedInner | any;

    /**
     * 
     * @type {boolean}
     * @memberof GetFiltersResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetFiltersResponse
     */
    'collectionId': number;
    /**
     * 
     * @type {Array<GetFiltersResponseCreatedInner>}
     * @memberof GetFiltersResponse
     */
    'created': Array<GetFiltersResponseCreatedInner>;
    /**
     * 
     * @type {Array<GetFiltersResponseCreatedInner>}
     * @memberof GetFiltersResponse
     */
    'tags': Array<GetFiltersResponseCreatedInner>;
    /**
     * 
     * @type {Array<GetFiltersResponseCreatedInner>}
     * @memberof GetFiltersResponse
     */
    'types': Array<GetFiltersResponseCreatedInner>;
}
/**
 * 
 * @export
 * @interface GetFiltersResponseCreatedInner
 */
export interface GetFiltersResponseCreatedInner {
    /**
     * 
     * @type {string}
     * @memberof GetFiltersResponseCreatedInner
     */
    '_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetFiltersResponseCreatedInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetHighlightsInCollectionResponse
 */
export interface GetHighlightsInCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetHighlightsInCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetAllHighlightsResponseItemsInner>}
     * @memberof GetHighlightsInCollectionResponse
     */
    'items': Array<GetAllHighlightsResponseItemsInner>;
}
/**
 * @type GetOrRefreshToken200Response
 * @export
 */
export type GetOrRefreshToken200Response = TokenErrorResponse | TokenResponse;

/**
 * @type GetOrRefreshTokenRequest
 * @export
 */
export type GetOrRefreshTokenRequest = ObtainToken | RefreshToken;

/**
 * 
 * @export
 * @interface GetPublicUserByNameResponse
 */
export interface GetPublicUserByNameResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByNameResponse
     */
    'result': boolean;
    /**
     * 
     * @type {GetPublicUserByNameResponseUser}
     * @memberof GetPublicUserByNameResponse
     */
    'user': GetPublicUserByNameResponseUser;
}
/**
 * 
 * @export
 * @interface GetPublicUserByNameResponseUser
 */
export interface GetPublicUserByNameResponseUser {
    /**
     * 
     * @type {number}
     * @memberof GetPublicUserByNameResponseUser
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'avatar': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByNameResponseUser
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'registered': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByNameResponseUser
     */
    'lastUpdate': string;
    /**
     * 
     * @type {GetPublicUserByNameResponseUserConfig}
     * @memberof GetPublicUserByNameResponseUser
     */
    'config': GetPublicUserByNameResponseUserConfig;
}
/**
 * 
 * @export
 * @interface GetPublicUserByNameResponseUserConfig
 */
export interface GetPublicUserByNameResponseUserConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPublicUserByNameResponseUserConfig
     */
    'raindrops_hide': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByNameResponseUserConfig
     */
    'nested_view_legacy': boolean;
}
/**
 * 
 * @export
 * @interface GetRaindropResponse
 */
export interface GetRaindropResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetRaindropResponse
     */
    'result': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetRaindropResponse
     */
    'author': boolean;
    /**
     * 
     * @type {GetRaindropResponseItem}
     * @memberof GetRaindropResponse
     */
    'item': GetRaindropResponseItem;
}
/**
 * 
 * @export
 * @interface GetRaindropResponseItem
 */
export interface GetRaindropResponseItem {
    /**
     * 
     * @type {number}
     * @memberof GetRaindropResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof GetRaindropResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof GetRaindropResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof GetRaindropResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {Array<GetRaindropResponseItemHighlightsInner>}
     * @memberof GetRaindropResponseItem
     */
    'highlights': Array<GetRaindropResponseItemHighlightsInner>;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof GetRaindropResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetRaindropResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetRaindropResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRaindropResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof GetRaindropResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface GetRaindropResponseItemHighlightsInner
 */
export interface GetRaindropResponseItemHighlightsInner {
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    'lastUpdate': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof GetRaindropResponseItemHighlightsInner
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface GetRaindropsResponse
 */
export interface GetRaindropsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetRaindropsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetRaindropsResponse
     */
    'collectionId': number;
    /**
     * 
     * @type {number}
     * @memberof GetRaindropsResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GetRaindropResponseItem>}
     * @memberof GetRaindropsResponse
     */
    'items': Array<GetRaindropResponseItem>;
}
/**
 * 
 * @export
 * @interface GetRootCollectionsResponse
 */
export interface GetRootCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetRootCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Collection>}
     * @memberof GetRootCollectionsResponse
     */
    'items': Array<Collection>;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponse
 */
export interface GetSystemCollectionStatsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetSystemCollectionStatsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetSystemCollectionStatsResponseItemsInner>}
     * @memberof GetSystemCollectionStatsResponse
     */
    'items': Array<GetSystemCollectionStatsResponseItemsInner>;
    /**
     * 
     * @type {GetSystemCollectionStatsResponseMeta}
     * @memberof GetSystemCollectionStatsResponse
     */
    'meta': GetSystemCollectionStatsResponseMeta;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponseItemsInner
 */
export interface GetSystemCollectionStatsResponseItemsInner {
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseItemsInner
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseItemsInner
     */
    '_id': number;
}
/**
 * 
 * @export
 * @interface GetSystemCollectionStatsResponseMeta
 */
export interface GetSystemCollectionStatsResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    '_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSystemCollectionStatsResponseMeta
     */
    'changedBookmarksDate': string;
}
/**
 * 
 * @export
 * @interface GetTagsInCollectionResponse
 */
export interface GetTagsInCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetTagsInCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetFiltersResponseCreatedInner>}
     * @memberof GetTagsInCollectionResponse
     */
    'items': Array<GetFiltersResponseCreatedInner>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'hidden': boolean;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'sort': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Group
     */
    'collections': Array<number>;
}
/**
 * 
 * @export
 * @interface ImportHTMLBookmarkFileResponse
 */
export interface ImportHTMLBookmarkFileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ImportHTMLBookmarkFileResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<ImportHTMLBookmarkFileResponseItemFolder>}
     * @memberof ImportHTMLBookmarkFileResponse
     */
    'items': Array<ImportHTMLBookmarkFileResponseItemFolder>;
    /**
     * 
     * @type {ImportHTMLBookmarkFileResponseCount}
     * @memberof ImportHTMLBookmarkFileResponse
     */
    'count': ImportHTMLBookmarkFileResponseCount;
}
/**
 * 
 * @export
 * @interface ImportHTMLBookmarkFileResponseCount
 */
export interface ImportHTMLBookmarkFileResponseCount {
    /**
     * 
     * @type {number}
     * @memberof ImportHTMLBookmarkFileResponseCount
     */
    'bookmarks': number;
    /**
     * 
     * @type {number}
     * @memberof ImportHTMLBookmarkFileResponseCount
     */
    'folders': number;
    /**
     * 
     * @type {number}
     * @memberof ImportHTMLBookmarkFileResponseCount
     */
    'tags': number;
    /**
     * 
     * @type {number}
     * @memberof ImportHTMLBookmarkFileResponseCount
     */
    'highlights': number;
    /**
     * 
     * @type {number}
     * @memberof ImportHTMLBookmarkFileResponseCount
     */
    'duplicates': number;
}
/**
 * 
 * @export
 * @interface ImportHTMLBookmarkFileResponseItemBookmark
 */
export interface ImportHTMLBookmarkFileResponseItemBookmark {
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'lastUpdate': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'cover': string;
    /**
     * 
     * @type {Array<ParseURLResponseItemMediaInner>}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'media': Array<ParseURLResponseItemMediaInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ImportHTMLBookmarkFileResponseItemBookmark
     */
    'important': boolean;
}
/**
 * 
 * @export
 * @interface ImportHTMLBookmarkFileResponseItemFolder
 */
export interface ImportHTMLBookmarkFileResponseItemFolder {
    /**
     * 
     * @type {string}
     * @memberof ImportHTMLBookmarkFileResponseItemFolder
     */
    'title': string;
    /**
     * 
     * @type {Array<ImportHTMLBookmarkFileResponseItemFolder>}
     * @memberof ImportHTMLBookmarkFileResponseItemFolder
     */
    'folders': Array<ImportHTMLBookmarkFileResponseItemFolder>;
    /**
     * 
     * @type {Array<ImportHTMLBookmarkFileResponseItemBookmark>}
     * @memberof ImportHTMLBookmarkFileResponseItemFolder
     */
    'bookmarks': Array<ImportHTMLBookmarkFileResponseItemBookmark>;
}
/**
 * 
 * @export
 * @interface MergeCollectionsRequest
 */
export interface MergeCollectionsRequest {
    /**
     * 
     * @type {number}
     * @memberof MergeCollectionsRequest
     */
    'to'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof MergeCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface MergeCollectionsResponse
 */
export interface MergeCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MergeCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof MergeCollectionsResponse
     */
    'modified': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof MergeCollectionsResponse
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface ObtainToken
 */
export interface ObtainToken {
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'grant_type': ObtainTokenGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof ObtainToken
     */
    'redirect_uri': string;
}

export const ObtainTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code'
} as const;

export type ObtainTokenGrantTypeEnum = typeof ObtainTokenGrantTypeEnum[keyof typeof ObtainTokenGrantTypeEnum];

/**
 * 
 * @export
 * @interface ParseURLResponse
 */
export interface ParseURLResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ParseURLResponse
     */
    'result': boolean;
    /**
     * 
     * @type {ParseURLResponseItem}
     * @memberof ParseURLResponse
     */
    'item': ParseURLResponseItem;
}
/**
 * 
 * @export
 * @interface ParseURLResponseItem
 */
export interface ParseURLResponseItem {
    /**
     * 
     * @type {string}
     * @memberof ParseURLResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ParseURLResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof ParseURLResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {Array<ParseURLResponseItemMediaInner>}
     * @memberof ParseURLResponseItem
     */
    'media': Array<ParseURLResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof ParseURLResponseItem
     */
    'type': string;
    /**
     * 
     * @type {ParseURLResponseItemMeta}
     * @memberof ParseURLResponseItem
     */
    'meta': ParseURLResponseItemMeta;
}
/**
 * 
 * @export
 * @interface ParseURLResponseItemMediaInner
 */
export interface ParseURLResponseItemMediaInner {
    /**
     * 
     * @type {string}
     * @memberof ParseURLResponseItemMediaInner
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface ParseURLResponseItemMeta
 */
export interface ParseURLResponseItemMeta {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParseURLResponseItemMeta
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'grant_type': RefreshTokenGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'refresh_token': string;
}

export const RefreshTokenGrantTypeEnum = {
    RefreshToken: 'refresh_token'
} as const;

export type RefreshTokenGrantTypeEnum = typeof RefreshTokenGrantTypeEnum[keyof typeof RefreshTokenGrantTypeEnum];

/**
 * 
 * @export
 * @interface RemoveAllEmptyCollectionsResponse
 */
export interface RemoveAllEmptyCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveAllEmptyCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveAllEmptyCollectionsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface RemoveCollectionsRequest
 */
export interface RemoveCollectionsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveCollectionsResponse
 */
export interface RemoveCollectionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveCollectionsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveCollectionsResponse
     */
    'modified': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveCollectionsResponse
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveRaindropResponse
 */
export interface RemoveRaindropResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveRaindropResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {RemoveRaindropResponseItem}
     * @memberof RemoveRaindropResponse
     */
    'item'?: RemoveRaindropResponseItem;
}
/**
 * 
 * @export
 * @interface RemoveRaindropResponseItem
 */
export interface RemoveRaindropResponseItem {
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindropResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof RemoveRaindropResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindropResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof RemoveRaindropResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof RemoveRaindropResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'note': string;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindropResponseItem
     */
    'order': number;
    /**
     * 
     * @type {boolean}
     * @memberof RemoveRaindropResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindropResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveRaindropResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveRaindropResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof RemoveRaindropResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface RemoveRaindropsRequest
 */
export interface RemoveRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveRaindropsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveRaindropsResponse
 */
export interface RemoveRaindropsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveRaindropsResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindropsResponse
     */
    'modified': number;
}
/**
 * 
 * @export
 * @interface RemoveTagsFromCollectionRequest
 */
export interface RemoveTagsFromCollectionRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveTagsFromCollectionRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RenameOrMergeTagsRequest
 */
export interface RenameOrMergeTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof RenameOrMergeTagsRequest
     */
    'replace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RenameOrMergeTagsRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReorderAllCollectionsRequest
 */
export interface ReorderAllCollectionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReorderAllCollectionsRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReorderAllCollectionsRequest
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Member: 'member',
    Viewer: 'viewer'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface SearchCoversResponse
 */
export interface SearchCoversResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SearchCoversResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInner>}
     * @memberof SearchCoversResponse
     */
    'items': Array<SearchCoversResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface SearchCoversResponseItemsInner
 */
export interface SearchCoversResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof SearchCoversResponseItemsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<SearchCoversResponseItemsInnerIconsInner>}
     * @memberof SearchCoversResponseItemsInner
     */
    'icons': Array<SearchCoversResponseItemsInnerIconsInner>;
}
/**
 * 
 * @export
 * @interface SearchCoversResponseItemsInnerIconsInner
 */
export interface SearchCoversResponseItemsInnerIconsInner {
    /**
     * 
     * @type {string}
     * @memberof SearchCoversResponseItemsInnerIconsInner
     */
    'png': string;
}
/**
 * 
 * @export
 * @interface ShareCollectionRequest
 */
export interface ShareCollectionRequest {
    /**
     * 
     * @type {Role}
     * @memberof ShareCollectionRequest
     */
    'role': Role;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareCollectionRequest
     */
    'emails': Array<string>;
}


/**
 * 
 * @export
 * @interface ShareCollectionResponse
 */
export interface ShareCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ShareCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareCollectionResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ShareCollectionResponse
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SimpleResponse
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @interface SuggestForExistingBookmarkResponse
 */
export interface SuggestForExistingBookmarkResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuggestForExistingBookmarkResponse
     */
    'result'?: boolean;
}
/**
 * 
 * @export
 * @interface SuggestForNewBookmarkRequest
 */
export interface SuggestForNewBookmarkRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestForNewBookmarkRequest
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface SuggestForNewBookmarkResponse
 */
export interface SuggestForNewBookmarkResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuggestForNewBookmarkResponse
     */
    'result'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenErrorResponse
 */
export interface TokenErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenErrorResponse
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof TokenErrorResponse
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     * @deprecated
     */
    'expires'?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type': TokenResponseTokenTypeEnum;
}

export const TokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type TokenResponseTokenTypeEnum = typeof TokenResponseTokenTypeEnum[keyof typeof TokenResponseTokenTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCollectionRequest
 */
export interface UpdateCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'view'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCollectionRequest
     */
    'sort'?: number;
    /**
     * Collection and raindrops that it contains will be accessible without authentication?
     * @type {boolean}
     * @memberof UpdateCollectionRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UpdateCollectionRequest
     */
    'parent'?: CollectionRef | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCollectionRequest
     */
    'cover'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCollectionRequest
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateCollectionResponse
 */
export interface UpdateCollectionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCollectionResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Collection}
     * @memberof UpdateCollectionResponse
     */
    'item': Collection;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserRequest
 */
export interface UpdateCurrentUserRequest {
    /**
     * 
     * @type {Array<UpdateCurrentUserRequestGroupsInner>}
     * @memberof UpdateCurrentUserRequest
     */
    'groups'?: Array<UpdateCurrentUserRequestGroupsInner>;
    /**
     * 
     * @type {UserConfig}
     * @memberof UpdateCurrentUserRequest
     */
    'config'?: UserConfig;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'newpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'oldpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserRequestGroupsInner
 */
export interface UpdateCurrentUserRequestGroupsInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequestGroupsInner
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCurrentUserRequestGroupsInner
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateCurrentUserRequestGroupsInner
     */
    'sort'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateCurrentUserRequestGroupsInner
     */
    'collections'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserResponse
 */
export interface UpdateCurrentUserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCurrentUserResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UpdateCurrentUserResponseUser}
     * @memberof UpdateCurrentUserResponse
     */
    'user': UpdateCurrentUserResponseUser;
    /**
     * 
     * @type {UpdateCurrentUserResponseUser}
     * @memberof UpdateCurrentUserResponse
     */
    'item': UpdateCurrentUserResponseUser;
}
/**
 * 
 * @export
 * @interface UpdateCurrentUserResponseUser
 */
export interface UpdateCurrentUserResponseUser {
    /**
     * 
     * @type {number}
     * @memberof UpdateCurrentUserResponseUser
     */
    '_id': number;
    /**
     * 
     * @type {UserConfig}
     * @memberof UpdateCurrentUserResponseUser
     */
    'config': UserConfig;
    /**
     * 
     * @type {UserDropbox}
     * @memberof UpdateCurrentUserResponseUser
     */
    'dropbox'?: UserDropbox;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'email_MD5'?: string;
    /**
     * 
     * @type {UserFiles}
     * @memberof UpdateCurrentUserResponseUser
     */
    'files': UserFiles;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'fullName': string;
    /**
     * 
     * @type {UserDropbox}
     * @memberof UpdateCurrentUserResponseUser
     */
    'gdrive'?: UserDropbox;
    /**
     * 
     * @type {Array<Group>}
     * @memberof UpdateCurrentUserResponseUser
     */
    'groups': Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCurrentUserResponseUser
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCurrentUserResponseUser
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'proExpire'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'registered': string;
    /**
     * 
     * @type {UserTfa}
     * @memberof UpdateCurrentUserResponseUser
     */
    'tfa'?: UserTfa;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'lastAction'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'lastVisit'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserResponseUser
     */
    'lastUpdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCurrentUserResponseUser
     */
    '__v'?: number;
}
/**
 * 
 * @export
 * @interface UpdateRaindropResponse
 */
export interface UpdateRaindropResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRaindropResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {UpdateRaindropResponseItem}
     * @memberof UpdateRaindropResponse
     */
    'item'?: UpdateRaindropResponseItem;
}
/**
 * 
 * @export
 * @interface UpdateRaindropResponseItem
 */
export interface UpdateRaindropResponseItem {
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropResponseItem
     */
    '__v': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UpdateRaindropResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof UpdateRaindropResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof UpdateRaindropResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRaindropResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof UpdateRaindropResponseItem
     */
    'user': UserRef;
    /**
     * 
     * @type {Array<GetRaindropResponseItemHighlightsInner>}
     * @memberof UpdateRaindropResponseItem
     */
    'highlights': Array<GetRaindropResponseItemHighlightsInner>;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsRequest
 */
export interface UpdateRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateRaindropsRequest
     */
    'ids'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRaindropsRequest
     */
    'important'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'media'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRaindropsRequest
     */
    'cover'?: string;
    /**
     * 
     * @type {UpdateRaindropsRequestCollection}
     * @memberof UpdateRaindropsRequest
     */
    'collection'?: UpdateRaindropsRequestCollection;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsRequestCollection
 */
export interface UpdateRaindropsRequestCollection {
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropsRequestCollection
     */
    '$id'?: number;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsResponse
 */
export interface UpdateRaindropsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRaindropsResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropsResponse
     */
    'modified'?: number;
}
/**
 * 
 * @export
 * @interface UploadCollectionCoverResponse
 */
export interface UploadCollectionCoverResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UploadCollectionCoverResponseItem}
     * @memberof UploadCollectionCoverResponse
     */
    'item': UploadCollectionCoverResponseItem;
}
/**
 * 
 * @export
 * @interface UploadCollectionCoverResponseItem
 */
export interface UploadCollectionCoverResponseItem {
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'description': string;
    /**
     * 
     * @type {UserRef}
     * @memberof UploadCollectionCoverResponseItem
     */
    'user': UserRef;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'view': string;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UploadCollectionCoverResponseItem
     */
    'cover': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'expanded': boolean;
    /**
     * 
     * @type {CreatorRef}
     * @memberof UploadCollectionCoverResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'lastAction': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof UploadCollectionCoverResponseItem
     */
    'color'?: string;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof UploadCollectionCoverResponseItem
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {boolean}
     * @memberof UploadCollectionCoverResponseItem
     */
    'author': boolean;
    /**
     * 
     * @type {object}
     * @memberof UploadCollectionCoverResponseItem
     */
    'parent': object | null;
    /**
     * 
     * @type {number}
     * @memberof UploadCollectionCoverResponseItem
     */
    '__v': number;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UploadFileResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UploadFileResponseItem}
     * @memberof UploadFileResponse
     */
    'item': UploadFileResponseItem;
}
/**
 * 
 * @export
 * @interface UploadFileResponseItem
 */
export interface UploadFileResponseItem {
    /**
     * 
     * @type {number}
     * @memberof UploadFileResponseItem
     */
    '__v': number;
    /**
     * 
     * @type {number}
     * @memberof UploadFileResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UploadFileResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof UploadFileResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof UploadFileResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {UploadFileResponseItemFile}
     * @memberof UploadFileResponseItem
     */
    'file': UploadFileResponseItemFile;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof UploadFileResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadFileResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof UploadFileResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UploadFileResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof UploadFileResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface UploadFileResponseItemFile
 */
export interface UploadFileResponseItemFile {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItemFile
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UploadFileResponseItemFile
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponseItemFile
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UploadRaindropCoverResponse
 */
export interface UploadRaindropCoverResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UploadRaindropCoverResponse
     */
    'result'?: boolean;
    /**
     * 
     * @type {UploadRaindropCoverResponseItem}
     * @memberof UploadRaindropCoverResponse
     */
    'item'?: UploadRaindropCoverResponseItem;
}
/**
 * 
 * @export
 * @interface UploadRaindropCoverResponseItem
 */
export interface UploadRaindropCoverResponseItem {
    /**
     * 
     * @type {number}
     * @memberof UploadRaindropCoverResponseItem
     */
    '__v': number;
    /**
     * 
     * @type {number}
     * @memberof UploadRaindropCoverResponseItem
     */
    '_id': number;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UploadRaindropCoverResponseItem
     */
    'collection': CollectionRef | null;
    /**
     * 
     * @type {number}
     * @memberof UploadRaindropCoverResponseItem
     */
    'collectionId': number;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'cover': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'created': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof UploadRaindropCoverResponseItem
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'lastUpdate': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'link': string;
    /**
     * 
     * @type {Array<CreateRaindropResponseItemMediaInner>}
     * @memberof UploadRaindropCoverResponseItem
     */
    'media': Array<CreateRaindropResponseItemMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadRaindropCoverResponseItem
     */
    'removed': boolean;
    /**
     * 
     * @type {number}
     * @memberof UploadRaindropCoverResponseItem
     */
    'sort': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UploadRaindropCoverResponseItem
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRaindropCoverResponseItem
     */
    'type': string;
    /**
     * 
     * @type {UserRef}
     * @memberof UploadRaindropCoverResponseItem
     */
    'user': UserRef;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    '_id': number;
    /**
     * 
     * @type {UserConfig}
     * @memberof User
     */
    'config': UserConfig;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'dropbox'?: UserDropbox;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email_MD5'?: string;
    /**
     * 
     * @type {UserFiles}
     * @memberof User
     */
    'files': UserFiles;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'gdrive'?: UserDropbox;
    /**
     * 
     * @type {Array<Group>}
     * @memberof User
     */
    'groups': Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'proExpire'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'registered': string;
    /**
     * 
     * @type {UserTfa}
     * @memberof User
     */
    'tfa'?: UserTfa;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastAction'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastVisit'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastUpdate'?: string;
}
/**
 * 
 * @export
 * @interface UserConfig
 */
export interface UserConfig {
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'broken_level': string;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'font_color'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'font_size': number;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'lang'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'last_collection': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'raindrops_buttons'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'raindrops_hide'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'raindrops_search_by_score'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'raindrops_search_incollection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'raindrops_sort': string;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'default_collection_view'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'nested_view_legacy'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'add_default_collection'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfig
     */
    'acknowledge'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'ai_suggestions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfig
     */
    'filters_hide'?: boolean;
}
/**
 * 
 * @export
 * @interface UserDropbox
 */
export interface UserDropbox {
    /**
     * 
     * @type {boolean}
     * @memberof UserDropbox
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserFiles
 */
export interface UserFiles {
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'used': number;
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UserFiles
     */
    'lastCheckPoint': string;
}
/**
 * 
 * @export
 * @interface UserRef
 */
export interface UserRef {
    /**
     * 
     * @type {number}
     * @memberof UserRef
     */
    '$id': number;
    /**
     * 
     * @type {string}
     * @memberof UserRef
     */
    '$ref': string;
}
/**
 * 
 * @export
 * @interface UserTfa
 */
export interface UserTfa {
    /**
     * 
     * @type {boolean}
     * @memberof UserTfa
     */
    'enabled'?: boolean;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorize', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorize', 'clientId', clientId)
            const localVarPath = `/v1/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken: async (getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/oauth/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrRefreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrRefreshToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrRefreshToken(getOrRefreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getOrRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(redirectUri: string, clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorize(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: any): AxiosPromise<GetOrRefreshToken200Response> {
            return localVarFp.getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authorize(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authorize(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptInvitation', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/join`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel: async (userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeCollaboratorAccessLevelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (createCollectionRequest?: CreateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator: async (userId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCollaborator', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollaborator', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection/-99`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/childrens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollaborators', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/covers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections: async (mergeCollectionsRequest?: MergeCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/clean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections: async (removeCollectionsRequest?: RemoveCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections: async (reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderAllCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers: async (text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchCovers', 'text', text)
            const localVarPath = `/rest/v1/collections/covers/{text}`
                .replace(`{${"text"}}`, encodeURIComponent(String(text)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection: async (id: number, shareCollectionRequest?: ShareCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shareCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unshareOrLeaveCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (id: number, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover: async (id: number, cover?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadCollectionCover', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvitation(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptInvitation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvitation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.acceptInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.changeCollaboratorAccessLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(createCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.createCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollaborator(userId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollaborator(userId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.deleteCollaborator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.emptyTrash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChildCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChildCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getChildCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborators(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborators(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getCollaborators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedCovers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeaturedCoversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedCovers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getFeaturedCovers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRootCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getRootCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemCollectionStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getSystemCollectionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MergeCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeCollections(mergeCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.mergeCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllEmptyCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveAllEmptyCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllEmptyCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeAllEmptyCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollections(removeCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.removeCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderAllCollections(reorderAllCollectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.reorderAllCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCovers(text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCoversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCovers(text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.searchCovers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareCollection(id, shareCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.shareCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareOrLeaveCollection(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareOrLeaveCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.unshareOrLeaveCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(id, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.updateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCollectionCover(id: number, cover?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadCollectionCoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCollectionCover(id, cover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.uploadCollectionCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(id: number, options?: any): AxiosPromise<AcceptInvitation200Response> {
            return localVarFp.acceptInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: any): AxiosPromise<void> {
            return localVarFp.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(createCollectionRequest?: CreateCollectionRequest, options?: any): AxiosPromise<CreateCollectionResponse> {
            return localVarFp.createCollection(createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator(userId: number, id: number, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.deleteCollaborator(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections(options?: any): AxiosPromise<GetChildCollectionsResponse> {
            return localVarFp.getChildCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getCollaborators(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: number, options?: any): AxiosPromise<GetCollectionResponse> {
            return localVarFp.getCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers(options?: any): AxiosPromise<GetFeaturedCoversResponse> {
            return localVarFp.getFeaturedCovers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections(options?: any): AxiosPromise<GetRootCollectionsResponse> {
            return localVarFp.getRootCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<GetSystemCollectionStatsResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: any): AxiosPromise<MergeCollectionsResponse> {
            return localVarFp.mergeCollections(mergeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections(options?: any): AxiosPromise<RemoveAllEmptyCollectionsResponse> {
            return localVarFp.removeAllEmptyCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection(id: number, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.removeCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: any): AxiosPromise<RemoveCollectionsResponse> {
            return localVarFp.removeCollections(removeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers(text: string, options?: any): AxiosPromise<SearchCoversResponse> {
            return localVarFp.searchCovers(text, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: any): AxiosPromise<ShareCollectionResponse> {
            return localVarFp.shareCollection(id, shareCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection(id: number, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.unshareOrLeaveCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: any): AxiosPromise<UpdateCollectionResponse> {
            return localVarFp.updateCollection(id, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover(id: number, cover?: File, options?: any): AxiosPromise<UploadCollectionCoverResponse> {
            return localVarFp.uploadCollectionCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public acceptInvitation(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).acceptInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).createCollection(createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteCollaborator(userId: number, id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteCollaborator(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public emptyTrash(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getChildCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getChildCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollaborators(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollaborators(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getFeaturedCovers(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getFeaturedCovers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getRootCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getRootCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getSystemCollectionStats(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).mergeCollections(mergeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeAllEmptyCollections(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeAllEmptyCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollections(removeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public searchCovers(text: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).searchCovers(text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {ShareCollectionRequest} [shareCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).shareCollection(id, shareCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public unshareOrLeaveCollection(id: number, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).unshareOrLeaveCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public updateCollection(id: number, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).updateCollection(id, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {File} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public uploadCollectionCover(id: number, cover?: File, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).uploadCollectionCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getFilters', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/filters/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagsSort !== undefined) {
                localVarQueryParameter['tagsSort'] = tagsSort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFiltersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(collectionId, tagsSort, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilterApi.getFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterApiFp(configuration)
    return {
        /**
         * 
         * @param {number} collectionId 
         * @param {GetFiltersTagsSortEnum} [tagsSort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: any): AxiosPromise<GetFiltersResponse> {
            return localVarFp.getFilters(collectionId, tagsSort, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @param {number} collectionId 
     * @param {GetFiltersTagsSortEnum} [tagsSort] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: RawAxiosRequestConfig) {
        return FilterApiFp(this.configuration).getFilters(collectionId, tagsSort, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFiltersTagsSortEnum = {
    MinusCount: '-count',
    Id: '_id'
} as const;
export type GetFiltersTagsSortEnum = typeof GetFiltersTagsSortEnum[keyof typeof GetFiltersTagsSortEnum];


/**
 * HighlightApi - axios parameter creator
 * @export
 */
export const HighlightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights: async (page?: number, perpage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/highlights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection: async (collectionId: number, page?: number, perpage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getHighlightsInCollection', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/highlights/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HighlightApi - functional programming interface
 * @export
 */
export const HighlightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HighlightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllHighlights(page?: number, perpage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllHighlightsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllHighlights(page, perpage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getAllHighlights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHighlightsInCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightsInCollection(collectionId, page, perpage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getHighlightsInCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.getRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HighlightApi.updateRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HighlightApi - factory interface
 * @export
 */
export const HighlightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HighlightApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights(page?: number, perpage?: number, options?: any): AxiosPromise<GetAllHighlightsResponse> {
            return localVarFp.getAllHighlights(page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {number} [page] 
         * @param {number} [perpage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: any): AxiosPromise<GetHighlightsInCollectionResponse> {
            return localVarFp.getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<GetRaindropResponse> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, body?: object, options?: any): AxiosPromise<UpdateRaindropResponse> {
            return localVarFp.updateRaindrop(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HighlightApi - object-oriented interface
 * @export
 * @class HighlightApi
 * @extends {BaseAPI}
 */
export class HighlightApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [perpage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getAllHighlights(page?: number, perpage?: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getAllHighlights(page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {number} [page] 
     * @param {number} [perpage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public updateRaindrop(id: number, body?: object, options?: RawAxiosRequestConfig) {
        return HighlightApiFp(this.configuration).updateRaindrop(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist: async (checkURLsExistRequest?: CheckURLsExistRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkURLsExistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile: async (_import?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (_import !== undefined) { 
                localVarFormParams.append('import', _import as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL: async (url?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckURLsExistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkURLsExist(checkURLsExistRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.checkURLsExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importHTMLBookmarkFile(_import?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportHTMLBookmarkFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importHTMLBookmarkFile(_import, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importHTMLBookmarkFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseURL(url?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseURL(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.parseURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: any): AxiosPromise<CheckURLsExistResponse> {
            return localVarFp.checkURLsExist(checkURLsExistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [_import] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile(_import?: File, options?: any): AxiosPromise<ImportHTMLBookmarkFileResponse> {
            return localVarFp.importHTMLBookmarkFile(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL(url?: string, options?: any): AxiosPromise<ParseURLResponse> {
            return localVarFp.parseURL(url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * 
     * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).checkURLsExist(checkURLsExistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [_import] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importHTMLBookmarkFile(_import?: File, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importHTMLBookmarkFile(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [url] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public parseURL(url?: string, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).parseURL(url, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RaindropApi - axios parameter creator
 * @export
 */
export const RaindropApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop: async (createRaindropRequest?: CreateRaindropRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindropRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermanentCopy', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cache`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops: async (collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops: async (collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('removeRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('suggestForExistingBookmark', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/suggest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark: async (suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestForNewBookmarkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops: async (collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: File, collectionId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (collectionId !== undefined) { 
                localVarFormParams.append('collectionId', collectionId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover: async (id: number, cover?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadRaindropCover', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaindropApi - functional programming interface
 * @export
 */
export const RaindropApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaindropApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrop(createRaindropRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.createRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrops(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRaindropsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrops(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.createRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermanentCopy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermanentCopy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getPermanentCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRaindropsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrops(collectionId, sort, perpage, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.getRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrop(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.removeRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveRaindropsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrops(collectionId, search, removeRaindropsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.removeRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForExistingBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestForExistingBookmarkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForExistingBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.suggestForExistingBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestForNewBookmarkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForNewBookmark(suggestForNewBookmarkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.suggestForNewBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateRaindropResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.updateRaindrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateRaindropsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrops(collectionId, updateRaindropsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.updateRaindrops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: File, collectionId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRaindropCover(id: number, cover?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRaindropCoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRaindropCover(id, cover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaindropApi.uploadRaindropCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RaindropApi - factory interface
 * @export
 */
export const RaindropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaindropApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRaindropRequest} [createRaindropRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: any): AxiosPromise<CreateRaindropResponse> {
            return localVarFp.createRaindrop(createRaindropRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops(body?: object, options?: any): AxiosPromise<CreateRaindropsResponse> {
            return localVarFp.createRaindrops(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getPermanentCopy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<GetRaindropResponse> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: any): AxiosPromise<GetRaindropsResponse> {
            return localVarFp.getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop(id: number, options?: any): AxiosPromise<RemoveRaindropResponse> {
            return localVarFp.removeRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: any): AxiosPromise<RemoveRaindropsResponse> {
            return localVarFp.removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark(id: number, options?: any): AxiosPromise<SuggestForExistingBookmarkResponse> {
            return localVarFp.suggestForExistingBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: any): AxiosPromise<SuggestForNewBookmarkResponse> {
            return localVarFp.suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, body?: object, options?: any): AxiosPromise<UpdateRaindropResponse> {
            return localVarFp.updateRaindrop(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} collectionId 
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: any): AxiosPromise<UpdateRaindropsResponse> {
            return localVarFp.updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [file] 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: File, collectionId?: number, options?: any): AxiosPromise<UploadFileResponse> {
            return localVarFp.uploadFile(file, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover(id: number, cover?: File, options?: any): AxiosPromise<UploadRaindropCoverResponse> {
            return localVarFp.uploadRaindropCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaindropApi - object-oriented interface
 * @export
 * @class RaindropApi
 * @extends {BaseAPI}
 */
export class RaindropApi extends BaseAPI {
    /**
     * 
     * @param {CreateRaindropRequest} [createRaindropRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrop(createRaindropRequest?: CreateRaindropRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrop(createRaindropRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrops(body?: object, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrops(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getPermanentCopy(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getPermanentCopy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {string} [sort] 
     * @param {number} [perpage] 
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrop(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {string} [search] 
     * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForExistingBookmark(id: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForExistingBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrop(id: number, body?: object, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrop(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} collectionId 
     * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [file] 
     * @param {number} [collectionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadFile(file?: File, collectionId?: number, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadFile(file, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {File} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadRaindropCover(id: number, cover?: File, options?: RawAxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadRaindropCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection: async (collectionId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection: async (collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeTagsFromCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags: async (collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameOrMergeTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsInCollection(collectionId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTagsInCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagsInCollection(collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.getTagsInCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.removeTagsFromCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.renameOrMergeTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [collectionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection(collectionId?: number, options?: any): AxiosPromise<GetTagsInCollectionResponse> {
            return localVarFp.getTagsInCollection(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [collectionId] 
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {number} [collectionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagsInCollection(collectionId?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagsInCollection(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [collectionId] 
     * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [collectionId] 
     * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider: async (provider: ConnectSocialNetworkProviderProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider: async (provider: DisconnectSocialNetworkProviderProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('disconnectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}/revoke`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName: async (name: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPublicUserByName', 'name', name)
            const localVarPath = `/rest/v1/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (updateCurrentUserRequest?: UpdateCurrentUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCurrentUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectSocialNetworkProvider(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.connectSocialNetworkProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectSocialNetworkProvider(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.disconnectSocialNetworkProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCurrentUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUserByName(name: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicUserByNameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUserByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getPublicUserByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemCollectionStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getSystemCollectionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCurrentUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(updateCurrentUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.connectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.disconnectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<GetCurrentUserResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName(name: number, options?: any): AxiosPromise<GetPublicUserByNameResponse> {
            return localVarFp.getPublicUserByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<GetSystemCollectionStatsResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: any): AxiosPromise<UpdateCurrentUserResponse> {
            return localVarFp.updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {ConnectSocialNetworkProviderProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).connectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DisconnectSocialNetworkProviderProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).disconnectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUserByName(name: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getPublicUserByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSystemCollectionStats(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type ConnectSocialNetworkProviderProviderEnum = typeof ConnectSocialNetworkProviderProviderEnum[keyof typeof ConnectSocialNetworkProviderProviderEnum];
/**
 * @export
 */
export const DisconnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type DisconnectSocialNetworkProviderProviderEnum = typeof DisconnectSocialNetworkProviderProviderEnum[keyof typeof DisconnectSocialNetworkProviderProviderEnum];


