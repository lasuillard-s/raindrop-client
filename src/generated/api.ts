/* tslint:disable */
/* eslint-disable */
/**
 * Raindrop API (Unofficial)
 * **UNOFFICIAL** OpenAPI specification of Raindrop API.  This OpenAPI spec has been made by hand with reference to official documentation because it is not provided by Raindrop.io.  Because official documentation not maintained well, there are very (highly) likely to have mismatch in schemas. As we can\'t inspect and address all issues, schema being updated as we find issues.  Any contributions are welcome. Bug report, schema update, adding descriptions or functions, please don\'t hesitate to create an issue.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptInvitation200Response
 */
export interface AcceptInvitation200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptInvitation200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {Role}
     * @memberof AcceptInvitation200Response
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface Bookmark
 */
export interface Bookmark {
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'lastUpdate': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bookmark
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'excerpt': string;
}
/**
 * 
 * @export
 * @interface ChangeCollaboratorAccessLevelRequest
 */
export interface ChangeCollaboratorAccessLevelRequest {
    /**
     * 
     * @type {Role}
     * @memberof ChangeCollaboratorAccessLevelRequest
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface CheckURLsExist200Response
 */
export interface CheckURLsExist200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CheckURLsExist200Response
     */
    'result': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CheckURLsExist200Response
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CheckURLsExistRequest
 */
export interface CheckURLsExistRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckURLsExistRequest
     */
    'urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * The id of the collection.
     * @type {number}
     * @memberof Collection
     */
    '_id': number;
    /**
     * 
     * @type {CollectionAccess}
     * @memberof Collection
     */
    'access': CollectionAccess;
    /**
     * 
     * @type {CollectionCollaborators}
     * @memberof Collection
     */
    'collaborators': CollectionCollaborators;
    /**
     * Primary color of collection cover as HEX
     * @type {string}
     * @memberof Collection
     */
    'color': string;
    /**
     * Count of raindrops in collection
     * @type {number}
     * @memberof Collection
     */
    'count': number;
    /**
     * Collection cover URL. This array always have one item due to legacy reasons
     * @type {Array<string>}
     * @memberof Collection
     */
    'cover': Array<string>;
    /**
     * When collection is created
     * @type {string}
     * @memberof Collection
     */
    'created': string;
    /**
     * Whether the collectionâ€™s sub-collections are expanded
     * @type {boolean}
     * @memberof Collection
     */
    'expanded': boolean;
    /**
     * When collection is updated
     * @type {string}
     * @memberof Collection
     */
    'lastUpdate': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof Collection
     */
    'parent': CollectionRef;
    /**
     * Collection and raindrops that it contains will be accessible without authentication by public link
     * @type {boolean}
     * @memberof Collection
     */
    'public': boolean;
    /**
     * The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
     * @type {number}
     * @memberof Collection
     */
    'sort': number;
    /**
     * Name of the collection
     * @type {string}
     * @memberof Collection
     */
    'title': string;
    /**
     * 
     * @type {CollectionUser}
     * @memberof Collection
     */
    'user': CollectionUser;
    /**
     * 
     * @type {View}
     * @memberof Collection
     */
    'view': View;
}


/**
 * 
 * @export
 * @interface CollectionAccess
 */
export interface CollectionAccess {
    /**
     * 1. read only access (equal to public=true) 2. collaborator with read only access 3. collaborator with write only access 4. owner
     * @type {number}
     * @memberof CollectionAccess
     */
    'level': CollectionAccessLevelEnum;
    /**
     * Does it possible to change parent of this collection?
     * @type {boolean}
     * @memberof CollectionAccess
     */
    'draggable': boolean;
}

export const CollectionAccessLevelEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type CollectionAccessLevelEnum = typeof CollectionAccessLevelEnum[keyof typeof CollectionAccessLevelEnum];

/**
 * 
 * @export
 * @interface CollectionCollaborators
 */
export interface CollectionCollaborators {
    /**
     * 
     * @type {string}
     * @memberof CollectionCollaborators
     */
    '$ref': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionCollaborators
     */
    '$id': number;
}
/**
 * 
 * @export
 * @interface CollectionRef
 */
export interface CollectionRef {
    /**
     * 
     * @type {string}
     * @memberof CollectionRef
     */
    '$ref': CollectionRefRefEnum;
    /**
     * The id of the parent collection. Not specified for root collections
     * @type {number}
     * @memberof CollectionRef
     */
    '$id': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionRef
     */
    'oid': number;
}

export const CollectionRefRefEnum = {
    Collections: 'collections'
} as const;

export type CollectionRefRefEnum = typeof CollectionRefRefEnum[keyof typeof CollectionRefRefEnum];

/**
 * 
 * @export
 * @interface CollectionResponseMany
 */
export interface CollectionResponseMany {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionResponseMany
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Collection>}
     * @memberof CollectionResponseMany
     */
    'items': Array<Collection>;
}
/**
 * 
 * @export
 * @interface CollectionResponseOne
 */
export interface CollectionResponseOne {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionResponseOne
     */
    'result': boolean;
    /**
     * 
     * @type {Collection}
     * @memberof CollectionResponseOne
     */
    'item'?: Collection;
}
/**
 * 
 * @export
 * @interface CollectionUser
 */
export interface CollectionUser {
    /**
     * 
     * @type {string}
     * @memberof CollectionUser
     */
    '$ref': string;
    /**
     * Owner ID
     * @type {number}
     * @memberof CollectionUser
     */
    '$id': number;
}
/**
 * 
 * @export
 * @interface Cover
 */
export interface Cover {
    /**
     * 
     * @type {string}
     * @memberof Cover
     */
    'title': string;
    /**
     * 
     * @type {Array<CoverIconsInner>}
     * @memberof Cover
     */
    'icons': Array<CoverIconsInner>;
}
/**
 * 
 * @export
 * @interface CoverIconsInner
 */
export interface CoverIconsInner {
    /**
     * 
     * @type {string}
     * @memberof CoverIconsInner
     */
    'png': string;
    /**
     * 
     * @type {string}
     * @memberof CoverIconsInner
     */
    'svg'?: string;
}
/**
 * 
 * @export
 * @interface CoverResponse
 */
export interface CoverResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CoverResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Cover>}
     * @memberof CoverResponse
     */
    'items': Array<Cover>;
}
/**
 * 
 * @export
 * @interface CreateCollection
 */
export interface CreateCollection {
    /**
     * 
     * @type {View}
     * @memberof CreateCollection
     */
    'view': View;
    /**
     * Name of the collection
     * @type {string}
     * @memberof CreateCollection
     */
    'title': string;
    /**
     * The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
     * @type {number}
     * @memberof CreateCollection
     */
    'sort': number;
    /**
     * Collection and raindrops that it contains will be accessible without authentication?
     * @type {boolean}
     * @memberof CreateCollection
     */
    'public': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateCollection
     */
    'parent': CollectionRef;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCollection
     */
    'cover': Array<string>;
}


/**
 * 
 * @export
 * @interface CreateCollection400Response
 */
export interface CreateCollection400Response {
    /**
     * 
     * @type {boolean}
     * @memberof CreateCollection400Response
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCollection400Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollection400Response
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface CreateRaindrop
 */
export interface CreateRaindrop {
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'lastUpdate': string;
    /**
     * Specify sort order (ascending).  For example if you want to move raindrop to the first place set this field to 0
     * @type {number}
     * @memberof CreateRaindrop
     */
    'sort'?: number;
    /**
     * Marked as \"favorite\"
     * @type {boolean}
     * @memberof CreateRaindrop
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof CreateRaindrop
     */
    'reminder': RaindropBaseReminder;
    /**
     * Tags list
     * @type {Array<string>}
     * @memberof CreateRaindrop
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof CreateRaindrop
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof CreateRaindrop
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaindrop
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof CreateRaindrop
     */
    'highlights': Array<Highlight>;
    /**
     * Specify empty object to automatically parse meta data (cover, description, html) in the background
     * @type {object}
     * @memberof CreateRaindrop
     */
    'pleaseParse'?: object;
}
/**
 * 
 * @export
 * @interface CreateRaindropsRequest
 */
export interface CreateRaindropsRequest {
    /**
     * Array of objects. Format of single object described in \"Create single raindrop\". Maximum 100 objects in array!
     * @type {Array<CreateRaindrop>}
     * @memberof CreateRaindropsRequest
     */
    'items'?: Array<CreateRaindrop>;
}
/**
 * 
 * @export
 * @interface CreatorRef
 */
export interface CreatorRef {
    /**
     * 
     * @type {number}
     * @memberof CreatorRef
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreatorRef
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorRef
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorRef
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterBroken}
     * @memberof Filter
     */
    'broken': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof Filter
     */
    'duplicates': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof Filter
     */
    'important': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof Filter
     */
    'notag': FilterBroken;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof Filter
     */
    'tags': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof Filter
     */
    'types': Array<FilterTagsInner>;
}
/**
 * 
 * @export
 * @interface FilterBroken
 */
export interface FilterBroken {
    /**
     * 
     * @type {number}
     * @memberof FilterBroken
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FilterResponse
 */
export interface FilterResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FilterResponse
     */
    'result': boolean;
    /**
     * 
     * @type {FilterBroken}
     * @memberof FilterResponse
     */
    'broken': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof FilterResponse
     */
    'duplicates': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof FilterResponse
     */
    'important': FilterBroken;
    /**
     * 
     * @type {FilterBroken}
     * @memberof FilterResponse
     */
    'notag': FilterBroken;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof FilterResponse
     */
    'tags': Array<FilterTagsInner>;
    /**
     * 
     * @type {Array<FilterTagsInner>}
     * @memberof FilterResponse
     */
    'types': Array<FilterTagsInner>;
}
/**
 * 
 * @export
 * @interface FilterTagsInner
 */
export interface FilterTagsInner {
    /**
     * 
     * @type {string}
     * @memberof FilterTagsInner
     */
    '_id': string;
    /**
     * 
     * @type {number}
     * @memberof FilterTagsInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'title': string;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof Folder
     */
    'folders': Array<Folder>;
    /**
     * 
     * @type {Array<Bookmark>}
     * @memberof Folder
     */
    'bookmarks': Array<Bookmark>;
}
/**
 * @type GetOrRefreshToken200Response
 * @export
 */
export type GetOrRefreshToken200Response = TokenErrorResponse | TokenResponse;

/**
 * 
 * @export
 * @interface GetOrRefreshToken400Response
 */
export interface GetOrRefreshToken400Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrRefreshToken400Response
     */
    'error'?: GetOrRefreshToken400ResponseErrorEnum;
}

export const GetOrRefreshToken400ResponseErrorEnum = {
    BadAuthorizationCode: 'bad_authorization_code'
} as const;

export type GetOrRefreshToken400ResponseErrorEnum = typeof GetOrRefreshToken400ResponseErrorEnum[keyof typeof GetOrRefreshToken400ResponseErrorEnum];

/**
 * @type GetOrRefreshTokenRequest
 * @export
 */
export type GetOrRefreshTokenRequest = ObtainToken | RefreshToken;

/**
 * 
 * @export
 * @interface GetPublicUserByName200Response
 */
export interface GetPublicUserByName200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByName200Response
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPublicUserByName200Response
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'email_MD5'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'fullName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicUserByName200Response
     */
    'pro'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetPublicUserByName200Response
     */
    'registered'?: string;
}
/**
 * 
 * @export
 * @interface GetTagsInCollection200Response
 */
export interface GetTagsInCollection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetTagsInCollection200Response
     */
    'result': boolean;
    /**
     * 
     * @type {Array<GetTagsInCollection200ResponseAllOfItemsInner>}
     * @memberof GetTagsInCollection200Response
     */
    'items'?: Array<GetTagsInCollection200ResponseAllOfItemsInner>;
}
/**
 * 
 * @export
 * @interface GetTagsInCollection200ResponseAllOfItemsInner
 */
export interface GetTagsInCollection200ResponseAllOfItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetTagsInCollection200ResponseAllOfItemsInner
     */
    '_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTagsInCollection200ResponseAllOfItemsInner
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'hidden': boolean;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'sort': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Group
     */
    'collections': Array<number>;
}
/**
 * 
 * @export
 * @interface Highlight
 */
export interface Highlight {
    /**
     * Unique id of highlight
     * @type {string}
     * @memberof Highlight
     */
    '_id': string;
    /**
     * Text of highlight (required)
     * @type {string}
     * @memberof Highlight
     */
    'text': string;
    /**
     * Color of highlight. Default yellow  Can be blue, brown, cyan, gray, green, indigo, orange, pink, purple, red, teal, yellow
     * @type {string}
     * @memberof Highlight
     */
    'color': HighlightColorEnum;
    /**
     * Optional note for highlight
     * @type {string}
     * @memberof Highlight
     */
    'note': string;
    /**
     * Creation date of highlight
     * @type {string}
     * @memberof Highlight
     */
    'created': string;
}

export const HighlightColorEnum = {
    Blue: 'blue',
    Brown: 'brown',
    Cyan: 'cyan',
    Gray: 'gray',
    Green: 'green',
    Indigo: 'indigo',
    Orange: 'orange',
    Pink: 'pink',
    Purple: 'purple',
    Red: 'red',
    Teal: 'teal',
    Yellow: 'yellow'
} as const;

export type HighlightColorEnum = typeof HighlightColorEnum[keyof typeof HighlightColorEnum];

/**
 * 
 * @export
 * @interface HighlightItem
 */
export interface HighlightItem {
    /**
     * Unique id of highlight
     * @type {string}
     * @memberof HighlightItem
     */
    '_id': string;
    /**
     * Text of highlight (required)
     * @type {string}
     * @memberof HighlightItem
     */
    'text': string;
    /**
     * Color of highlight. Default yellow  Can be blue, brown, cyan, gray, green, indigo, orange, pink, purple, red, teal, yellow
     * @type {string}
     * @memberof HighlightItem
     */
    'color': HighlightItemColorEnum;
    /**
     * Optional note for highlight
     * @type {string}
     * @memberof HighlightItem
     */
    'note': string;
    /**
     * Creation date of highlight
     * @type {string}
     * @memberof HighlightItem
     */
    'created': string;
    /**
     * 
     * @type {number}
     * @memberof HighlightItem
     */
    'raindropRef': number;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof HighlightItem
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HighlightItem
     */
    'tags': Array<string>;
}

export const HighlightItemColorEnum = {
    Blue: 'blue',
    Brown: 'brown',
    Cyan: 'cyan',
    Gray: 'gray',
    Green: 'green',
    Indigo: 'indigo',
    Orange: 'orange',
    Pink: 'pink',
    Purple: 'purple',
    Red: 'red',
    Teal: 'teal',
    Yellow: 'yellow'
} as const;

export type HighlightItemColorEnum = typeof HighlightItemColorEnum[keyof typeof HighlightItemColorEnum];

/**
 * 
 * @export
 * @interface HighlightResponse
 */
export interface HighlightResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HighlightResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<HighlightItem>}
     * @memberof HighlightResponse
     */
    'items': Array<HighlightItem>;
}
/**
 * 
 * @export
 * @interface ImportFileResponse
 */
export interface ImportFileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ImportFileResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof ImportFileResponse
     */
    'items': Array<Folder>;
}
/**
 * 
 * @export
 * @interface MergeCollectionsRequest
 */
export interface MergeCollectionsRequest {
    /**
     * Collection ID. Reserved system collection IDs are:  - -99 for Trash - -1 for Unsorted - 0 for All
     * @type {number}
     * @memberof MergeCollectionsRequest
     */
    'to'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof MergeCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ObtainToken
 */
export interface ObtainToken {
    /**
     * Grant type
     * @type {string}
     * @memberof ObtainToken
     */
    'grant_type': ObtainTokenGrantTypeEnum;
    /**
     * Received authorization code
     * @type {string}
     * @memberof ObtainToken
     */
    'code': string;
    /**
     * Unique client ID of your Raindrop.io app
     * @type {string}
     * @memberof ObtainToken
     */
    'client_id': string;
    /**
     * Client secret of your Raindrop.io app
     * @type {string}
     * @memberof ObtainToken
     */
    'client_secret': string;
    /**
     * Redirect URI registered at your Raindrop.io app
     * @type {string}
     * @memberof ObtainToken
     */
    'redirect_uri': string;
}

export const ObtainTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code'
} as const;

export type ObtainTokenGrantTypeEnum = typeof ObtainTokenGrantTypeEnum[keyof typeof ObtainTokenGrantTypeEnum];

/**
 * @type ParseURL200Response
 * @export
 */
export type ParseURL200Response = ParseUrlErrorResponse | ParseUrlResponse;

/**
 * 
 * @export
 * @interface ParseUrlErrorResponse
 */
export interface ParseUrlErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ParseUrlErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParseUrlErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ParseUrlErrorResponse
     */
    'errorMessage': string;
    /**
     * 
     * @type {UrlParse}
     * @memberof ParseUrlErrorResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface ParseUrlResponse
 */
export interface ParseUrlResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ParseUrlResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UrlParse}
     * @memberof ParseUrlResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface Raindrop
 */
export interface Raindrop {
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'lastUpdate': string;
    /**
     * Specify sort order (ascending).  For example if you want to move raindrop to the first place set this field to 0
     * @type {number}
     * @memberof Raindrop
     */
    'sort'?: number;
    /**
     * Marked as \"favorite\"
     * @type {boolean}
     * @memberof Raindrop
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof Raindrop
     */
    'reminder': RaindropBaseReminder;
    /**
     * Tags list
     * @type {Array<string>}
     * @memberof Raindrop
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof Raindrop
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof Raindrop
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Raindrop
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof Raindrop
     */
    'highlights': Array<Highlight>;
    /**
     * Unique identifier
     * @type {number}
     * @memberof Raindrop
     */
    '_id': number;
    /**
     * Hostname of a link. Files always have `raindrop.io` hostname
     * @type {string}
     * @memberof Raindrop
     */
    'domain': string;
    /**
     * 
     * @type {CreatorRef}
     * @memberof Raindrop
     */
    'creatorRef': CreatorRef;
    /**
     * 
     * @type {UserRef}
     * @memberof Raindrop
     */
    'user': UserRef;
    /**
     * Marked as broken (original link is not reachable anymore)
     * @type {boolean}
     * @memberof Raindrop
     */
    'broken': boolean;
    /**
     * 
     * @type {RaindropAllOfCache}
     * @memberof Raindrop
     */
    'cache': RaindropAllOfCache;
    /**
     * 
     * @type {RaindropAllOfFile}
     * @memberof Raindrop
     */
    'file'?: RaindropAllOfFile;
}
/**
 * Permanent copy (cached version) details
 * @export
 * @interface RaindropAllOfCache
 */
export interface RaindropAllOfCache {
    /**
     * ready retry failed invalid-origin invalid-timeout or invalid-size
     * @type {string}
     * @memberof RaindropAllOfCache
     */
    'status': RaindropAllOfCacheStatusEnum;
    /**
     * Full size in bytes
     * @type {number}
     * @memberof RaindropAllOfCache
     */
    'size': number;
    /**
     * Date when copy is successfully made
     * @type {string}
     * @memberof RaindropAllOfCache
     */
    'created': string;
}

export const RaindropAllOfCacheStatusEnum = {
    Ready: 'ready',
    Retry: 'retry',
    Failed: 'failed',
    InvalidOrigin: 'invalid-origin',
    InvalidTimeout: 'invalid-timeout',
    InvalidSize: 'invalid-size'
} as const;

export type RaindropAllOfCacheStatusEnum = typeof RaindropAllOfCacheStatusEnum[keyof typeof RaindropAllOfCacheStatusEnum];

/**
 * This raindrop uploaded from desktop [Supported file formats](https://help.raindrop.io/article/48-uploading-files)
 * @export
 * @interface RaindropAllOfFile
 */
export interface RaindropAllOfFile {
    /**
     * File name
     * @type {string}
     * @memberof RaindropAllOfFile
     */
    'name': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof RaindropAllOfFile
     */
    'size': number;
    /**
     * Mime type
     * @type {string}
     * @memberof RaindropAllOfFile
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RaindropBase
 */
export interface RaindropBase {
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'lastUpdate': string;
    /**
     * Specify sort order (ascending).  For example if you want to move raindrop to the first place set this field to 0
     * @type {number}
     * @memberof RaindropBase
     */
    'sort'?: number;
    /**
     * Marked as \"favorite\"
     * @type {boolean}
     * @memberof RaindropBase
     */
    'important': boolean;
    /**
     * 
     * @type {RaindropBaseReminder}
     * @memberof RaindropBase
     */
    'reminder': RaindropBaseReminder;
    /**
     * Tags list
     * @type {Array<string>}
     * @memberof RaindropBase
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<RaindropBaseMediaInner>}
     * @memberof RaindropBase
     */
    'media': Array<RaindropBaseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'cover': string;
    /**
     * 
     * @type {CollectionRef}
     * @memberof RaindropBase
     */
    'collection': CollectionRef;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'excerpt': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RaindropBase
     */
    'link': string;
    /**
     * 
     * @type {Array<Highlight>}
     * @memberof RaindropBase
     */
    'highlights': Array<Highlight>;
}
/**
 * 
 * @export
 * @interface RaindropBaseMediaInner
 */
export interface RaindropBaseMediaInner {
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseMediaInner
     */
    'type': RaindropBaseMediaInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseMediaInner
     */
    'link': string;
}

export const RaindropBaseMediaInnerTypeEnum = {
    Link: 'link',
    Image: 'image'
} as const;

export type RaindropBaseMediaInnerTypeEnum = typeof RaindropBaseMediaInnerTypeEnum[keyof typeof RaindropBaseMediaInnerTypeEnum];

/**
 * 
 * @export
 * @interface RaindropBaseReminder
 */
export interface RaindropBaseReminder {
    /**
     * 
     * @type {string}
     * @memberof RaindropBaseReminder
     */
    'date': string | null;
}
/**
 * 
 * @export
 * @interface RaindropResponseMany
 */
export interface RaindropResponseMany {
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseMany
     */
    'result': boolean;
    /**
     * 
     * @type {Array<Raindrop>}
     * @memberof RaindropResponseMany
     */
    'items': Array<Raindrop>;
    /**
     * 
     * @type {number}
     * @memberof RaindropResponseMany
     */
    'count': number;
    /**
     * Collection ID. Reserved system collection IDs are:  - -99 for Trash - -1 for Unsorted - 0 for All
     * @type {number}
     * @memberof RaindropResponseMany
     */
    'collectionId': number;
}
/**
 * 
 * @export
 * @interface RaindropResponseOne
 */
export interface RaindropResponseOne {
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseOne
     */
    'result': boolean;
    /**
     * 
     * @type {Raindrop}
     * @memberof RaindropResponseOne
     */
    'item': Raindrop;
    /**
     * 
     * @type {boolean}
     * @memberof RaindropResponseOne
     */
    'author': boolean;
}
/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * Unique client ID of your Raindrop.io app
     * @type {string}
     * @memberof RefreshToken
     */
    'client_id': string;
    /**
     * Client secret of your Raindrop.io app
     * @type {string}
     * @memberof RefreshToken
     */
    'client_secret': string;
    /**
     * Grant type
     * @type {string}
     * @memberof RefreshToken
     */
    'grant_type': RefreshTokenGrantTypeEnum;
    /**
     * Refresh token received when obtain access token
     * @type {string}
     * @memberof RefreshToken
     */
    'refresh_token': string;
}

export const RefreshTokenGrantTypeEnum = {
    RefreshToken: 'refresh_token'
} as const;

export type RefreshTokenGrantTypeEnum = typeof RefreshTokenGrantTypeEnum[keyof typeof RefreshTokenGrantTypeEnum];

/**
 * 
 * @export
 * @interface RemoveAllEmptyCollections200Response
 */
export interface RemoveAllEmptyCollections200Response {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveAllEmptyCollections200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveAllEmptyCollections200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface RemoveCollectionsRequest
 */
export interface RemoveCollectionsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveCollectionsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveRaindrops200Response
 */
export interface RemoveRaindrops200Response {
    /**
     * 
     * @type {boolean}
     * @memberof RemoveRaindrops200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RemoveRaindrops200Response
     */
    'modified'?: number;
}
/**
 * 
 * @export
 * @interface RemoveRaindropsRequest
 */
export interface RemoveRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof RemoveRaindropsRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RemoveTagsFromCollectionRequest
 */
export interface RemoveTagsFromCollectionRequest {
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof RemoveTagsFromCollectionRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RenameOrMergeTagsRequest
 */
export interface RenameOrMergeTagsRequest {
    /**
     * New name
     * @type {string}
     * @memberof RenameOrMergeTagsRequest
     */
    'replace'?: string;
    /**
     * Rename: Specify **array** with **only one** string (name of a tag)  Merge: List of tags
     * @type {Array<string>}
     * @memberof RenameOrMergeTagsRequest
     */
    'tags'?: Array<string>;
}
/**
 * @type ReorderAllCollectionsRequest
 * @export
 */
export type ReorderAllCollectionsRequest = ReorderAllCollectionsRequestOneOf | ReorderAllCollectionsRequestOneOf1;

/**
 * 
 * @export
 * @interface ReorderAllCollectionsRequestOneOf
 */
export interface ReorderAllCollectionsRequestOneOf {
    /**
     * 
     * @type {SortBy}
     * @memberof ReorderAllCollectionsRequestOneOf
     */
    'sort'?: SortBy;
}


/**
 * 
 * @export
 * @interface ReorderAllCollectionsRequestOneOf1
 */
export interface ReorderAllCollectionsRequestOneOf1 {
    /**
     * TRUE = expand all  FALSE = collapse all
     * @type {boolean}
     * @memberof ReorderAllCollectionsRequestOneOf1
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {boolean}
     * @memberof Response
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Member: 'member',
    Viewer: 'viewer'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface ShareCollection200Response
 */
export interface ShareCollection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ShareCollection200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareCollection200Response
     */
    'emails'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ShareCollection400Response
 */
export interface ShareCollection400Response {
    /**
     * 
     * @type {boolean}
     * @memberof ShareCollection400Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareCollection400Response
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface ShareCollectionRequest
 */
export interface ShareCollectionRequest {
    /**
     * 
     * @type {Role}
     * @memberof ShareCollectionRequest
     */
    'role'?: Role;
    /**
     * The user email(s) with whom to share the project.  Maximum 10
     * @type {Array<string>}
     * @memberof ShareCollectionRequest
     */
    'emails'?: Array<string>;
}


/**
 * Change order of all collections.  Possible values:  \"title\" - sort alphabetically ascending  \"-title\" - sort alphabetically descending  \"-count\" - sort by raindrops count descending
 * @export
 * @enum {string}
 */

export const SortBy = {
    Title: 'title',
    Title2: '-title',
    Count: '-count',
    LastUpdate: '-lastUpdate'
} as const;

export type SortBy = typeof SortBy[keyof typeof SortBy];


/**
 * 
 * @export
 * @interface StatResponse
 */
export interface StatResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StatResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Array<StatResponseAllOfItems>}
     * @memberof StatResponse
     */
    'items': Array<StatResponseAllOfItems>;
    /**
     * 
     * @type {StatResponseAllOfMeta}
     * @memberof StatResponse
     */
    'meta': StatResponseAllOfMeta;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfItems
 */
export interface StatResponseAllOfItems {
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfItems
     */
    '_id': number;
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfItems
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfMeta
 */
export interface StatResponseAllOfMeta {
    /**
     * 
     * @type {boolean}
     * @memberof StatResponseAllOfMeta
     */
    'pro': boolean;
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfMeta
     */
    '_id': number;
    /**
     * 
     * @type {string}
     * @memberof StatResponseAllOfMeta
     */
    'changedBookmarksDate': string;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof StatResponseAllOfMeta
     */
    'duplicates': StatResponseAllOfMetaDuplicates;
    /**
     * 
     * @type {StatResponseAllOfMetaDuplicates}
     * @memberof StatResponseAllOfMeta
     */
    'broken': StatResponseAllOfMetaDuplicates;
}
/**
 * 
 * @export
 * @interface StatResponseAllOfMetaDuplicates
 */
export interface StatResponseAllOfMetaDuplicates {
    /**
     * 
     * @type {number}
     * @memberof StatResponseAllOfMetaDuplicates
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Suggest
 */
export interface Suggest {
    /**
     * 
     * @type {Array<CollectionRef>}
     * @memberof Suggest
     */
    'collections': Array<CollectionRef>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Suggest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface SuggestForNewBookmarkRequest
 */
export interface SuggestForNewBookmarkRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestForNewBookmarkRequest
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface SuggestResponse
 */
export interface SuggestResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuggestResponse
     */
    'result': boolean;
    /**
     * 
     * @type {Suggest}
     * @memberof SuggestResponse
     */
    'item': Suggest;
}
/**
 * 
 * @export
 * @interface TokenErrorResponse
 */
export interface TokenErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenErrorResponse
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof TokenErrorResponse
     */
    'errorMessage': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * API access token
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * Token used to refresh access token
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
    /**
     * Remaining time until access token expires, in miliseconds
     * @type {number}
     * @memberof TokenResponse
     * @deprecated
     */
    'expires'?: number;
    /**
     * Reamining time until access token expires, in seconds
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
    /**
     * Type of token
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type': TokenResponseTokenTypeEnum;
}

export const TokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type TokenResponseTokenTypeEnum = typeof TokenResponseTokenTypeEnum[keyof typeof TokenResponseTokenTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCollection
 */
export interface UpdateCollection {
    /**
     * 
     * @type {View}
     * @memberof UpdateCollection
     */
    'view': View;
    /**
     * Name of the collection
     * @type {string}
     * @memberof UpdateCollection
     */
    'title': string;
    /**
     * The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
     * @type {number}
     * @memberof UpdateCollection
     */
    'sort': number;
    /**
     * Collection and raindrops that it contains will be accessible without authentication?
     * @type {boolean}
     * @memberof UpdateCollection
     */
    'public': boolean;
    /**
     * 
     * @type {CollectionRef}
     * @memberof UpdateCollection
     */
    'parent': CollectionRef;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCollection
     */
    'cover': Array<string>;
    /**
     * Whether the collection`s sub-collections are expanded
     * @type {boolean}
     * @memberof UpdateCollection
     */
    'expanded': boolean;
}


/**
 * 
 * @export
 * @interface UpdateCurrentUserRequest
 */
export interface UpdateCurrentUserRequest {
    /**
     * 
     * @type {Array<Group>}
     * @memberof UpdateCurrentUserRequest
     */
    'groups'?: Array<Group>;
    /**
     * 
     * @type {UserConfig}
     * @memberof UpdateCurrentUserRequest
     */
    'config'?: UserConfig;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'newpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'oldpassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRaindropsRequest
 */
export interface UpdateRaindropsRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateRaindropsRequest
     */
    'ids'?: Array<number>;
    /**
     * TRUE - mark as \"favorite\"  FALSE - unmark as \"favorite\"
     * @type {boolean}
     * @memberof UpdateRaindropsRequest
     */
    'important'?: boolean;
    /**
     * Will append specified tags to raindrops. Or will remove all tags from raindrops if [] (empty array) is specified
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRaindropsRequest
     */
    'media'?: Array<string>;
    /**
     * Set URL for cover. Tip: specify <screenshot> to set screenshots for all raindrops
     * @type {string}
     * @memberof UpdateRaindropsRequest
     */
    'cover'?: string;
    /**
     * 
     * @type {UpdateRaindropsRequestCollection}
     * @memberof UpdateRaindropsRequest
     */
    'collection'?: UpdateRaindropsRequestCollection;
}
/**
 * Specify {\"$id\": collectionId} to move raindrops to other collection
 * @export
 * @interface UpdateRaindropsRequestCollection
 */
export interface UpdateRaindropsRequestCollection {
    /**
     * 
     * @type {number}
     * @memberof UpdateRaindropsRequestCollection
     */
    '$id'?: number;
}
/**
 * 
 * @export
 * @interface UrlParse
 */
export interface UrlParse {
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'excerpt': string;
    /**
     * 
     * @type {Array<UrlParseMediaInner>}
     * @memberof UrlParse
     */
    'media': Array<UrlParseMediaInner>;
    /**
     * 
     * @type {string}
     * @memberof UrlParse
     */
    'type': string;
    /**
     * 
     * @type {UrlParseMeta}
     * @memberof UrlParse
     */
    'meta': UrlParseMeta;
}
/**
 * 
 * @export
 * @interface UrlParseErrorResponse
 */
export interface UrlParseErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseErrorResponse
     */
    'result': boolean;
    /**
     * 
     * @type {string}
     * @memberof UrlParseErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseErrorResponse
     */
    'errorMessage': string;
    /**
     * 
     * @type {UrlParse}
     * @memberof UrlParseErrorResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface UrlParseMediaInner
 */
export interface UrlParseMediaInner {
    /**
     * 
     * @type {string}
     * @memberof UrlParseMediaInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMediaInner
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface UrlParseMeta
 */
export interface UrlParseMeta {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseMeta
     */
    'possibleArticle': boolean;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMeta
     */
    'canonical': string;
    /**
     * 
     * @type {string}
     * @memberof UrlParseMeta
     */
    'site': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UrlParseMeta
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UrlParseResponse
 */
export interface UrlParseResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UrlParseResponse
     */
    'result': boolean;
    /**
     * 
     * @type {UrlParse}
     * @memberof UrlParseResponse
     */
    'item': UrlParse;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    '_id': number;
    /**
     * 
     * @type {UserConfig}
     * @memberof User
     */
    'config': UserConfig;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'dropbox': UserDropbox;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email_MD5': string;
    /**
     * 
     * @type {UserFiles}
     * @memberof User
     */
    'files': UserFiles;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * 
     * @type {UserDropbox}
     * @memberof User
     */
    'gdrive': UserDropbox;
    /**
     * 
     * @type {Array<Group>}
     * @memberof User
     */
    'groups': Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'pro': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'proExpire': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'registered': string;
}
/**
 * 
 * @export
 * @interface UserConfig
 */
export interface UserConfig {
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'broken_level': string;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'font_color': string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'font_size': number;
    /**
     * 
     * @type {string}
     * @memberof UserConfig
     */
    'lang': string;
    /**
     * 
     * @type {number}
     * @memberof UserConfig
     */
    'last_collection': number;
    /**
     * 
     * @type {SortBy}
     * @memberof UserConfig
     */
    'raindrops_sort': SortBy;
    /**
     * 
     * @type {View}
     * @memberof UserConfig
     */
    'raindrops_view': View;
}


/**
 * 
 * @export
 * @interface UserDropbox
 */
export interface UserDropbox {
    /**
     * 
     * @type {boolean}
     * @memberof UserDropbox
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserFiles
 */
export interface UserFiles {
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'used': number;
    /**
     * 
     * @type {number}
     * @memberof UserFiles
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UserFiles
     */
    'lastCheckPoint': string;
}
/**
 * 
 * @export
 * @interface UserRef
 */
export interface UserRef {
    /**
     * 
     * @type {string}
     * @memberof UserRef
     */
    '$ref': string;
    /**
     * 
     * @type {number}
     * @memberof UserRef
     */
    '$id': number;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'result': boolean;
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    'user': User;
}
/**
 * View style of collection, can be: - list (default) - simple - grid - masonry    Pinterest like grid
 * @export
 * @enum {string}
 */

export const View = {
    List: 'list',
    Simple: 'simple',
    Grid: 'grid',
    Masonry: 'masonry'
} as const;

export type View = typeof View[keyof typeof View];



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Direct the user to our authorization URL with specified request parameters.  - If the user is not logged in, they will be asked to log in  - The user will be asked if he would like to grant your application access to his Raindrop.io data
         * @summary Authorization request
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (redirectUri: string, clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorize', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorize', 'clientId', clientId)
            const localVarPath = `/v1/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once you have the authorization code, you can exchange it for the `access_token` by doing a POST request with all required body parameters as JSON.  For security reasons access tokens (except \"test tokens\") will expire after two weeks. In this case you should request the new one, by calling POST request with body parameters (JSON). 
         * @summary Obtain or refresh access token
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken: async (getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/oauth/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrRefreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Direct the user to our authorization URL with specified request parameters.  - If the user is not logged in, they will be asked to log in  - The user will be asked if he would like to grant your application access to his Raindrop.io data
         * @summary Authorization request
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(redirectUri: string, clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(redirectUri, clientId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authorize']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Once you have the authorization code, you can exchange it for the `access_token` by doing a POST request with all required body parameters as JSON.  For security reasons access tokens (except \"test tokens\") will expire after two weeks. In this case you should request the new one, by calling POST request with body parameters (JSON). 
         * @summary Obtain or refresh access token
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrRefreshToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrRefreshToken(getOrRefreshTokenRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.getOrRefreshToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Direct the user to our authorization URL with specified request parameters.  - If the user is not logged in, they will be asked to log in  - The user will be asked if he would like to grant your application access to his Raindrop.io data
         * @summary Authorization request
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(redirectUri: string, clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorize(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Once you have the authorization code, you can exchange it for the `access_token` by doing a POST request with all required body parameters as JSON.  For security reasons access tokens (except \"test tokens\") will expire after two weeks. In this case you should request the new one, by calling POST request with body parameters (JSON). 
         * @summary Obtain or refresh access token
         * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: any): AxiosPromise<GetOrRefreshToken200Response> {
            return localVarFp.getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Direct the user to our authorization URL with specified request parameters.  - If the user is not logged in, they will be asked to log in  - The user will be asked if he would like to grant your application access to his Raindrop.io data
     * @summary Authorization request
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authorize(redirectUri: string, clientId: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authorize(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once you have the authorization code, you can exchange it for the `access_token` by doing a POST request with all required body parameters as JSON.  For security reasons access tokens (except \"test tokens\") will expire after two weeks. In this case you should request the new one, by calling POST request with body parameters (JSON). 
     * @summary Obtain or refresh access token
     * @param {GetOrRefreshTokenRequest} [getOrRefreshTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getOrRefreshToken(getOrRefreshTokenRequest?: GetOrRefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getOrRefreshToken(getOrRefreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept an invitation to join a shared collection
         * @summary Accept an invitation
         * @param {number} id Existing collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptInvitation', 'id', id)
            const localVarPath = `/rest/v1/collections/{id}/join`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change access level of collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel: async (userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeCollaboratorAccessLevel', 'id', id)
            const localVarPath = `/rest/v1/collections/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeCollaboratorAccessLevelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new collection
         * @summary Create collection
         * @param {CreateCollection} [createCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (createCollection?: CreateCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an user from shared collection
         * @summary Delete a collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator: async (userId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCollaborator', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollaborator', 'id', id)
            const localVarPath = `/rest/v1/collections/{id}/sharing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Empty Trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collection/-99`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns JSON-encoded array containing all nested collections (that have positive `parent.$id`)
         * @summary Get child collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/childrens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collaborators list of collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollaborators', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Featured covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/covers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns JSON-encoded array containing all root collections.
         * @summary Get root collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge multiple collections
         * @summary Merge collections
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections: async (mergeCollectionsRequest?: MergeCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all empty collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections/clean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an existing collection and all its descendants.  Raindrops will be moved to \"Trash\" collection
         * @summary Remove collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove multiple collections at once.  Nested collections are ignored (include ID\'s in ids array to remove them)
         * @summary Remove multiple collections
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections: async (removeCollectionsRequest?: RemoveCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates order of all collections
         * @summary Reorder all collections
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections: async (reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderAllCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for specific cover (icon)
         * @summary Search for cover
         * @param {string} text For example \&quot;pokemon\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers: async (text: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchCovers', 'text', text)
            const localVarPath = `/rest/v1/collections/covers/{text}`
                .replace(`{${"text"}}`, encodeURIComponent(String(text)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share collection with another user(s). As result invitation(s) will be send to specified email(s) with link to join collection.
         * @summary Share collection
         * @param {number} id Existing collection ID
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection: async (id: number, shareCollectionRequest?: ShareCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shareCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There two possible results of calling this method, depends on who authenticated user is: - Owner: collection will be unshared and all collaborators will be removed - Member or viewer: authenticated user will be removed from collaborators list
         * @summary Unshare or leave collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unshareOrLeaveCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/sharing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing collection
         * @summary Update collection
         * @param {number} id Collection ID
         * @param {UpdateCollection} [updateCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (id: number, updateCollection?: UpdateCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCollection', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It\'s possible to upload cover from desktop. PNG, GIF and JPEG supported
         * @summary Upload cover
         * @param {number} id Existing collection ID
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover: async (id: number, cover?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadCollectionCover', 'id', id)
            const localVarPath = `/rest/v1/collection/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept an invitation to join a shared collection
         * @summary Accept an invitation
         * @param {number} id Existing collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvitation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptInvitation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvitation(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.acceptInvitation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Change access level of collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.changeCollaboratorAccessLevel']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new collection
         * @summary Create collection
         * @param {CreateCollection} [createCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(createCollection?: CreateCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(createCollection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.createCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove an user from shared collection
         * @summary Delete a collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollaborator(userId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollaborator(userId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.deleteCollaborator']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Empty Trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.emptyTrash']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns JSON-encoded array containing all nested collections (that have positive `parent.$id`)
         * @summary Get child collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildCollections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChildCollections(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getChildCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get collaborators list of collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborators(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborators(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getCollaborators']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Featured covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedCovers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedCovers(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getFeaturedCovers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns JSON-encoded array containing all root collections.
         * @summary Get root collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootCollections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootCollections(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getRootCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.getSystemCollectionStats']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Merge multiple collections
         * @summary Merge collections
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeCollections(mergeCollectionsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.mergeCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all empty collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllEmptyCollections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveAllEmptyCollections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllEmptyCollections(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.removeAllEmptyCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove an existing collection and all its descendants.  Raindrops will be moved to \"Trash\" collection
         * @summary Remove collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollection(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.removeCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove multiple collections at once.  Nested collections are ignored (include ID\'s in ids array to remove them)
         * @summary Remove multiple collections
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCollections(removeCollectionsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.removeCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates order of all collections
         * @summary Reorder all collections
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderAllCollections(reorderAllCollectionsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.reorderAllCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Search for specific cover (icon)
         * @summary Search for cover
         * @param {string} text For example \&quot;pokemon\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCovers(text: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCovers(text, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.searchCovers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Share collection with another user(s). As result invitation(s) will be send to specified email(s) with link to join collection.
         * @summary Share collection
         * @param {number} id Existing collection ID
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareCollection(id, shareCollectionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.shareCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * There two possible results of calling this method, depends on who authenticated user is: - Owner: collection will be unshared and all collaborators will be removed - Member or viewer: authenticated user will be removed from collaborators list
         * @summary Unshare or leave collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareOrLeaveCollection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareOrLeaveCollection(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.unshareOrLeaveCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing collection
         * @summary Update collection
         * @param {number} id Collection ID
         * @param {UpdateCollection} [updateCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(id: number, updateCollection?: UpdateCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(id, updateCollection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.updateCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * It\'s possible to upload cover from desktop. PNG, GIF and JPEG supported
         * @summary Upload cover
         * @param {number} id Existing collection ID
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCollectionCover(id: number, cover?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCollectionCover(id, cover, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CollectionApi.uploadCollectionCover']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * Accept an invitation to join a shared collection
         * @summary Accept an invitation
         * @param {number} id Existing collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(id: number, options?: any): AxiosPromise<AcceptInvitation200Response> {
            return localVarFp.acceptInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change access level of collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: any): AxiosPromise<void> {
            return localVarFp.changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new collection
         * @summary Create collection
         * @param {CreateCollection} [createCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(createCollection?: CreateCollection, options?: any): AxiosPromise<CollectionResponseOne> {
            return localVarFp.createCollection(createCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an user from shared collection
         * @summary Delete a collaborator
         * @param {number} userId User ID of collaborator
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollaborator(userId: number, id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.deleteCollaborator(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Empty Trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: any): AxiosPromise<Response> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns JSON-encoded array containing all nested collections (that have positive `parent.$id`)
         * @summary Get child collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildCollections(options?: any): AxiosPromise<CollectionResponseMany> {
            return localVarFp.getChildCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collaborators list of collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborators(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getCollaborators(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: number, options?: any): AxiosPromise<CollectionResponseOne> {
            return localVarFp.getCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Featured covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedCovers(options?: any): AxiosPromise<CoverResponse> {
            return localVarFp.getFeaturedCovers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns JSON-encoded array containing all root collections.
         * @summary Get root collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootCollections(options?: any): AxiosPromise<CollectionResponseMany> {
            return localVarFp.getRootCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<StatResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Merge multiple collections
         * @summary Merge collections
         * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.mergeCollections(mergeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all empty collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllEmptyCollections(options?: any): AxiosPromise<RemoveAllEmptyCollections200Response> {
            return localVarFp.removeAllEmptyCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an existing collection and all its descendants.  Raindrops will be moved to \"Trash\" collection
         * @summary Remove collection
         * @param {number} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollection(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.removeCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove multiple collections at once.  Nested collections are ignored (include ID\'s in ids array to remove them)
         * @summary Remove multiple collections
         * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.removeCollections(removeCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates order of all collections
         * @summary Reorder all collections
         * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for specific cover (icon)
         * @summary Search for cover
         * @param {string} text For example \&quot;pokemon\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCovers(text: string, options?: any): AxiosPromise<CoverResponse> {
            return localVarFp.searchCovers(text, options).then((request) => request(axios, basePath));
        },
        /**
         * Share collection with another user(s). As result invitation(s) will be send to specified email(s) with link to join collection.
         * @summary Share collection
         * @param {number} id Existing collection ID
         * @param {ShareCollectionRequest} [shareCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: any): AxiosPromise<ShareCollection200Response> {
            return localVarFp.shareCollection(id, shareCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * There two possible results of calling this method, depends on who authenticated user is: - Owner: collection will be unshared and all collaborators will be removed - Member or viewer: authenticated user will be removed from collaborators list
         * @summary Unshare or leave collection
         * @param {number} id Existing collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareOrLeaveCollection(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.unshareOrLeaveCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing collection
         * @summary Update collection
         * @param {number} id Collection ID
         * @param {UpdateCollection} [updateCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(id: number, updateCollection?: UpdateCollection, options?: any): AxiosPromise<CollectionResponseOne> {
            return localVarFp.updateCollection(id, updateCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * It\'s possible to upload cover from desktop. PNG, GIF and JPEG supported
         * @summary Upload cover
         * @param {number} id Existing collection ID
         * @param {File} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCollectionCover(id: number, cover?: File, options?: any): AxiosPromise<CollectionResponseOne> {
            return localVarFp.uploadCollectionCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * Accept an invitation to join a shared collection
     * @summary Accept an invitation
     * @param {number} id Existing collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public acceptInvitation(id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).acceptInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change access level of collaborator
     * @param {number} userId User ID of collaborator
     * @param {number} id Existing collection ID
     * @param {ChangeCollaboratorAccessLevelRequest} [changeCollaboratorAccessLevelRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public changeCollaboratorAccessLevel(userId: number, id: number, changeCollaboratorAccessLevelRequest?: ChangeCollaboratorAccessLevelRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).changeCollaboratorAccessLevel(userId, id, changeCollaboratorAccessLevelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new collection
     * @summary Create collection
     * @param {CreateCollection} [createCollection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(createCollection?: CreateCollection, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).createCollection(createCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an user from shared collection
     * @summary Delete a collaborator
     * @param {number} userId User ID of collaborator
     * @param {number} id Existing collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteCollaborator(userId: number, id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteCollaborator(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Empty Trash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public emptyTrash(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns JSON-encoded array containing all nested collections (that have positive `parent.$id`)
     * @summary Get child collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getChildCollections(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getChildCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collaborators list of collection
     * @param {number} id Existing collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollaborators(id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollaborators(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collection
     * @param {number} id Collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollection(id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Featured covers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getFeaturedCovers(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getFeaturedCovers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns JSON-encoded array containing all root collections.
     * @summary Get root collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getRootCollections(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getRootCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get system collections count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getSystemCollectionStats(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merge multiple collections
     * @summary Merge collections
     * @param {MergeCollectionsRequest} [mergeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public mergeCollections(mergeCollectionsRequest?: MergeCollectionsRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).mergeCollections(mergeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all empty collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeAllEmptyCollections(options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeAllEmptyCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an existing collection and all its descendants.  Raindrops will be moved to \"Trash\" collection
     * @summary Remove collection
     * @param {number} id Collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollection(id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove multiple collections at once.  Nested collections are ignored (include ID\'s in ids array to remove them)
     * @summary Remove multiple collections
     * @param {RemoveCollectionsRequest} [removeCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeCollections(removeCollectionsRequest?: RemoveCollectionsRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).removeCollections(removeCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates order of all collections
     * @summary Reorder all collections
     * @param {ReorderAllCollectionsRequest} [reorderAllCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public reorderAllCollections(reorderAllCollectionsRequest?: ReorderAllCollectionsRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).reorderAllCollections(reorderAllCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for specific cover (icon)
     * @summary Search for cover
     * @param {string} text For example \&quot;pokemon\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public searchCovers(text: string, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).searchCovers(text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share collection with another user(s). As result invitation(s) will be send to specified email(s) with link to join collection.
     * @summary Share collection
     * @param {number} id Existing collection ID
     * @param {ShareCollectionRequest} [shareCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public shareCollection(id: number, shareCollectionRequest?: ShareCollectionRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).shareCollection(id, shareCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There two possible results of calling this method, depends on who authenticated user is: - Owner: collection will be unshared and all collaborators will be removed - Member or viewer: authenticated user will be removed from collaborators list
     * @summary Unshare or leave collection
     * @param {number} id Existing collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public unshareOrLeaveCollection(id: number, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).unshareOrLeaveCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing collection
     * @summary Update collection
     * @param {number} id Collection ID
     * @param {UpdateCollection} [updateCollection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public updateCollection(id: number, updateCollection?: UpdateCollection, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).updateCollection(id, updateCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It\'s possible to upload cover from desktop. PNG, GIF and JPEG supported
     * @summary Upload cover
     * @param {number} id Existing collection ID
     * @param {File} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public uploadCollectionCover(id: number, cover?: File, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).uploadCollectionCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get filters
         * @param {number} collectionId Collection ID
         * @param {GetFiltersTagsSortEnum} [tagsSort] Sort tags by: &#x60;-count&#x60; by count, default &#x60;_id&#x60; by name
         * @param {string} [search] Check \&quot;raindrops\&quot; documentation for more details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getFilters', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/filters/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagsSort !== undefined) {
                localVarQueryParameter['tagsSort'] = tagsSort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get filters
         * @param {number} collectionId Collection ID
         * @param {GetFiltersTagsSortEnum} [tagsSort] Sort tags by: &#x60;-count&#x60; by count, default &#x60;_id&#x60; by name
         * @param {string} [search] Check \&quot;raindrops\&quot; documentation for more details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(collectionId, tagsSort, search, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilterApi.getFilters']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterApiFp(configuration)
    return {
        /**
         * 
         * @summary Get filters
         * @param {number} collectionId Collection ID
         * @param {GetFiltersTagsSortEnum} [tagsSort] Sort tags by: &#x60;-count&#x60; by count, default &#x60;_id&#x60; by name
         * @param {string} [search] Check \&quot;raindrops\&quot; documentation for more details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: any): AxiosPromise<FilterResponse> {
            return localVarFp.getFilters(collectionId, tagsSort, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @summary Get filters
     * @param {number} collectionId Collection ID
     * @param {GetFiltersTagsSortEnum} [tagsSort] Sort tags by: &#x60;-count&#x60; by count, default &#x60;_id&#x60; by name
     * @param {string} [search] Check \&quot;raindrops\&quot; documentation for more details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getFilters(collectionId: number, tagsSort?: GetFiltersTagsSortEnum, search?: string, options?: AxiosRequestConfig) {
        return FilterApiFp(this.configuration).getFilters(collectionId, tagsSort, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFiltersTagsSortEnum = {
    Count: '-count',
    Id: '_id'
} as const;
export type GetFiltersTagsSortEnum = typeof GetFiltersTagsSortEnum[keyof typeof GetFiltersTagsSortEnum];


/**
 * HighlightApi - axios parameter creator
 * @export
 */
export const HighlightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all highlights
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights: async (page?: number, perpage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/highlights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all highlights in a collection
         * @param {number} collectionId Collection ID
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection: async (collectionId: number, page?: number, perpage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getHighlightsInCollection', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/highlights/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, createRaindrop?: CreateRaindrop, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindrop, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HighlightApi - functional programming interface
 * @export
 */
export const HighlightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HighlightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all highlights
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllHighlights(page?: number, perpage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HighlightResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllHighlights(page, perpage, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['HighlightApi.getAllHighlights']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all highlights in a collection
         * @param {number} collectionId Collection ID
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HighlightResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightsInCollection(collectionId, page, perpage, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['HighlightApi.getHighlightsInCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['HighlightApi.getRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, createRaindrop, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['HighlightApi.updateRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * HighlightApi - factory interface
 * @export
 */
export const HighlightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HighlightApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all highlights
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHighlights(page?: number, perpage?: number, options?: any): AxiosPromise<HighlightResponse> {
            return localVarFp.getAllHighlights(page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all highlights in a collection
         * @param {number} collectionId Collection ID
         * @param {number} [page] 
         * @param {number} [perpage] How many highlights per page. 50 max. Default 25
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: any): AxiosPromise<HighlightResponse> {
            return localVarFp.getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.updateRaindrop(id, createRaindrop, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HighlightApi - object-oriented interface
 * @export
 * @class HighlightApi
 * @extends {BaseAPI}
 */
export class HighlightApi extends BaseAPI {
    /**
     * 
     * @summary Get all highlights
     * @param {number} [page] 
     * @param {number} [perpage] How many highlights per page. 50 max. Default 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getAllHighlights(page?: number, perpage?: number, options?: AxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getAllHighlights(page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all highlights in a collection
     * @param {number} collectionId Collection ID
     * @param {number} [page] 
     * @param {number} [perpage] How many highlights per page. 50 max. Default 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getHighlightsInCollection(collectionId: number, page?: number, perpage?: number, options?: AxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getHighlightsInCollection(collectionId, page, perpage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get raindrop
     * @param {number} id Existing raindrop ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public getRaindrop(id: number, options?: AxiosRequestConfig) {
        return HighlightApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update raindrop
     * @param {number} id Existing raindrop ID
     * @param {CreateRaindrop} [createRaindrop] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HighlightApi
     */
    public updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig) {
        return HighlightApiFp(this.configuration).updateRaindrop(id, createRaindrop, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Does specified URL\'s are already saved?
         * @summary Check URL(s) existence
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist: async (checkURLsExistRequest?: CheckURLsExistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkURLsExistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert HTML bookmark file to JSON.  Support Nestcape, Pocket and Instapaper file formats
         * @summary Parse HTML import file
         * @param {File} [_import] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile: async (_import?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (_import !== undefined) { 
                localVarFormParams.append('import', _import as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse and extract useful info from any URL
         * @summary Parse URL
         * @param {string} [url] URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL: async (url?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/import/url/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * Does specified URL\'s are already saved?
         * @summary Check URL(s) existence
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckURLsExist200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkURLsExist(checkURLsExistRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImportApi.checkURLsExist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Convert HTML bookmark file to JSON.  Support Nestcape, Pocket and Instapaper file formats
         * @summary Parse HTML import file
         * @param {File} [_import] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importHTMLBookmarkFile(_import?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importHTMLBookmarkFile(_import, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImportApi.importHTMLBookmarkFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Parse and extract useful info from any URL
         * @summary Parse URL
         * @param {string} [url] URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseURL(url?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseURL200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseURL(url, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImportApi.parseURL']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * Does specified URL\'s are already saved?
         * @summary Check URL(s) existence
         * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: any): AxiosPromise<CheckURLsExist200Response> {
            return localVarFp.checkURLsExist(checkURLsExistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert HTML bookmark file to JSON.  Support Nestcape, Pocket and Instapaper file formats
         * @summary Parse HTML import file
         * @param {File} [_import] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importHTMLBookmarkFile(_import?: File, options?: any): AxiosPromise<ImportFileResponse> {
            return localVarFp.importHTMLBookmarkFile(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * Parse and extract useful info from any URL
         * @summary Parse URL
         * @param {string} [url] URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseURL(url?: string, options?: any): AxiosPromise<ParseURL200Response> {
            return localVarFp.parseURL(url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * Does specified URL\'s are already saved?
     * @summary Check URL(s) existence
     * @param {CheckURLsExistRequest} [checkURLsExistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public checkURLsExist(checkURLsExistRequest?: CheckURLsExistRequest, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).checkURLsExist(checkURLsExistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Convert HTML bookmark file to JSON.  Support Nestcape, Pocket and Instapaper file formats
     * @summary Parse HTML import file
     * @param {File} [_import] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importHTMLBookmarkFile(_import?: File, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).importHTMLBookmarkFile(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parse and extract useful info from any URL
     * @summary Parse URL
     * @param {string} [url] URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public parseURL(url?: string, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).parseURL(url, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RaindropApi - axios parameter creator
 * @export
 */
export const RaindropApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create raindrop
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop: async (createRaindrop?: CreateRaindrop, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindrop, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create many raindrops
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops: async (createRaindropsRequest?: CreateRaindropsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links permanently saved with all content (only in PRO plan). Using this method you can navigate to this copy.
         * @summary Get permanent copy
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermanentCopy', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cache`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops: async (collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When you remove raindrop it will be moved to user Trash collection. But if you try to remove raindrop from Trash, it will be removed permanently.
         * @summary Remove raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be moved to \"Trash\" When :collectionId is -99, raindrops will be permanently removed!
         * @summary Remove many raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops: async (collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('removeRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Suggest collection and tags for existing bookmark
         * @param {number} id Bookmark id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('suggestForExistingBookmark', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/suggest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Suggest collection and tags for new bookmark
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark: async (suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestForNewBookmarkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop: async (id: number, createRaindrop?: CreateRaindrop, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRaindrop', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRaindrop, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be updated. Possible fields that could be updated are described in \"Body Parameters\"
         * @summary Update many raindrops
         * @param {number} collectionId Collection ID
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops: async (collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateRaindrops', 'collectionId', collectionId)
            const localVarPath = `/rest/v1/raindrops/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRaindropsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make sure to send PUT request with [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST#example) body
         * @summary Upload file
         * @param {File} [file] File
         * @param {number} [collectionId] Collection Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: File, collectionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/raindrop/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (collectionId !== undefined) { 
                localVarFormParams.append('collectionId', collectionId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PNG, GIF or JPEG
         * @summary Upload cover
         * @param {number} id Existing raindrop ID
         * @param {File} [cover] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover: async (id: number, cover?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadRaindropCover', 'id', id)
            const localVarPath = `/rest/v1/raindrop/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaindropApi - functional programming interface
 * @export
 */
export const RaindropApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaindropApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create raindrop
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrop(createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrop(createRaindrop, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.createRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create many raindrops
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaindrops(createRaindropsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.createRaindrops']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Links permanently saved with all content (only in PRO plan). Using this method you can navigate to this copy.
         * @summary Get permanent copy
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermanentCopy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermanentCopy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.getPermanentCopy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrop(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrop(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.getRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseMany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaindrops(collectionId, sort, perpage, page, search, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.getRaindrops']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * When you remove raindrop it will be moved to user Trash collection. But if you try to remove raindrop from Trash, it will be removed permanently.
         * @summary Remove raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrop(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrop(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.removeRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be moved to \"Trash\" When :collectionId is -99, raindrops will be permanently removed!
         * @summary Remove many raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveRaindrops200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRaindrops(collectionId, search, removeRaindropsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.removeRaindrops']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Suggest collection and tags for existing bookmark
         * @param {number} id Bookmark id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForExistingBookmark(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForExistingBookmark(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.suggestForExistingBookmark']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Suggest collection and tags for new bookmark
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestForNewBookmark(suggestForNewBookmarkRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.suggestForNewBookmark']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrop(id, createRaindrop, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.updateRaindrop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be updated. Possible fields that could be updated are described in \"Body Parameters\"
         * @summary Update many raindrops
         * @param {number} collectionId Collection ID
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaindrops(collectionId, updateRaindropsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.updateRaindrops']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Make sure to send PUT request with [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST#example) body
         * @summary Upload file
         * @param {File} [file] File
         * @param {number} [collectionId] Collection Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: File, collectionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, collectionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.uploadFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PNG, GIF or JPEG
         * @summary Upload cover
         * @param {number} id Existing raindrop ID
         * @param {File} [cover] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRaindropCover(id: number, cover?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaindropResponseOne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRaindropCover(id, cover, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RaindropApi.uploadRaindropCover']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RaindropApi - factory interface
 * @export
 */
export const RaindropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaindropApiFp(configuration)
    return {
        /**
         * 
         * @summary Create raindrop
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrop(createRaindrop?: CreateRaindrop, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.createRaindrop(createRaindrop, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create many raindrops
         * @param {CreateRaindropsRequest} [createRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: any): AxiosPromise<RaindropResponseMany> {
            return localVarFp.createRaindrops(createRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Links permanently saved with all content (only in PRO plan). Using this method you can navigate to this copy.
         * @summary Get permanent copy
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermanentCopy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getPermanentCopy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrop(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [sort] 
         * @param {number} [perpage] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: any): AxiosPromise<RaindropResponseMany> {
            return localVarFp.getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * When you remove raindrop it will be moved to user Trash collection. But if you try to remove raindrop from Trash, it will be removed permanently.
         * @summary Remove raindrop
         * @param {number} id Existing raindrop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrop(id: number, options?: any): AxiosPromise<Response> {
            return localVarFp.removeRaindrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be moved to \"Trash\" When :collectionId is -99, raindrops will be permanently removed!
         * @summary Remove many raindrops
         * @param {number} collectionId Collection ID
         * @param {string} [search] 
         * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: any): AxiosPromise<RemoveRaindrops200Response> {
            return localVarFp.removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Suggest collection and tags for existing bookmark
         * @param {number} id Bookmark id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForExistingBookmark(id: number, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.suggestForExistingBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Suggest collection and tags for new bookmark
         * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update raindrop
         * @param {number} id Existing raindrop ID
         * @param {CreateRaindrop} [createRaindrop] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.updateRaindrop(id, createRaindrop, options).then((request) => request(axios, basePath));
        },
        /**
         * Specify optional search and/or ids parameters to limit raindrops that will be updated. Possible fields that could be updated are described in \"Body Parameters\"
         * @summary Update many raindrops
         * @param {number} collectionId Collection ID
         * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Make sure to send PUT request with [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST#example) body
         * @summary Upload file
         * @param {File} [file] File
         * @param {number} [collectionId] Collection Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: File, collectionId?: number, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.uploadFile(file, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * PNG, GIF or JPEG
         * @summary Upload cover
         * @param {number} id Existing raindrop ID
         * @param {File} [cover] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRaindropCover(id: number, cover?: File, options?: any): AxiosPromise<RaindropResponseOne> {
            return localVarFp.uploadRaindropCover(id, cover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaindropApi - object-oriented interface
 * @export
 * @class RaindropApi
 * @extends {BaseAPI}
 */
export class RaindropApi extends BaseAPI {
    /**
     * 
     * @summary Create raindrop
     * @param {CreateRaindrop} [createRaindrop] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrop(createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrop(createRaindrop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create many raindrops
     * @param {CreateRaindropsRequest} [createRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public createRaindrops(createRaindropsRequest?: CreateRaindropsRequest, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).createRaindrops(createRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links permanently saved with all content (only in PRO plan). Using this method you can navigate to this copy.
     * @summary Get permanent copy
     * @param {number} id Existing raindrop ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getPermanentCopy(id: number, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getPermanentCopy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get raindrop
     * @param {number} id Existing raindrop ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrop(id: number, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get raindrops
     * @param {number} collectionId Collection ID
     * @param {string} [sort] 
     * @param {number} [perpage] 
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public getRaindrops(collectionId: number, sort?: string, perpage?: number, page?: number, search?: string, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).getRaindrops(collectionId, sort, perpage, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When you remove raindrop it will be moved to user Trash collection. But if you try to remove raindrop from Trash, it will be removed permanently.
     * @summary Remove raindrop
     * @param {number} id Existing raindrop ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrop(id: number, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specify optional search and/or ids parameters to limit raindrops that will be moved to \"Trash\" When :collectionId is -99, raindrops will be permanently removed!
     * @summary Remove many raindrops
     * @param {number} collectionId Collection ID
     * @param {string} [search] 
     * @param {RemoveRaindropsRequest} [removeRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public removeRaindrops(collectionId: number, search?: string, removeRaindropsRequest?: RemoveRaindropsRequest, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).removeRaindrops(collectionId, search, removeRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Suggest collection and tags for existing bookmark
     * @param {number} id Bookmark id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForExistingBookmark(id: number, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForExistingBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Suggest collection and tags for new bookmark
     * @param {SuggestForNewBookmarkRequest} [suggestForNewBookmarkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public suggestForNewBookmark(suggestForNewBookmarkRequest?: SuggestForNewBookmarkRequest, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).suggestForNewBookmark(suggestForNewBookmarkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update raindrop
     * @param {number} id Existing raindrop ID
     * @param {CreateRaindrop} [createRaindrop] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrop(id: number, createRaindrop?: CreateRaindrop, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrop(id, createRaindrop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specify optional search and/or ids parameters to limit raindrops that will be updated. Possible fields that could be updated are described in \"Body Parameters\"
     * @summary Update many raindrops
     * @param {number} collectionId Collection ID
     * @param {UpdateRaindropsRequest} [updateRaindropsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public updateRaindrops(collectionId: number, updateRaindropsRequest?: UpdateRaindropsRequest, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).updateRaindrops(collectionId, updateRaindropsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make sure to send PUT request with [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST#example) body
     * @summary Upload file
     * @param {File} [file] File
     * @param {number} [collectionId] Collection Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadFile(file?: File, collectionId?: number, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadFile(file, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PNG, GIF or JPEG
     * @summary Upload cover
     * @param {number} id Existing raindrop ID
     * @param {File} [cover] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaindropApi
     */
    public uploadRaindropCover(id: number, cover?: File, options?: AxiosRequestConfig) {
        return RaindropApiFp(this.configuration).uploadRaindropCover(id, cover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get tags
         * @param {number} [collectionId] Optional collection ID, when not specified all tags from all collections will be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection: async (collectionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection: async (collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeTagsFromCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename tag / Merge tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags: async (collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/tags/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameOrMergeTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get tags
         * @param {number} [collectionId] Optional collection ID, when not specified all tags from all collections will be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsInCollection(collectionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTagsInCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagsInCollection(collectionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagApi.getTagsInCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Remove tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagApi.removeTagsFromCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Rename tag / Merge tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagApi.renameOrMergeTags']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Get tags
         * @param {number} [collectionId] Optional collection ID, when not specified all tags from all collections will be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInCollection(collectionId?: number, options?: any): AxiosPromise<GetTagsInCollection200Response> {
            return localVarFp.getTagsInCollection(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename tag / Merge tags
         * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
         * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Get tags
     * @param {number} [collectionId] Optional collection ID, when not specified all tags from all collections will be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagsInCollection(collectionId?: number, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagsInCollection(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags
     * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
     * @param {RemoveTagsFromCollectionRequest} [removeTagsFromCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public removeTagsFromCollection(collectionId?: number, removeTagsFromCollectionRequest?: RemoveTagsFromCollectionRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).removeTagsFromCollection(collectionId, removeTagsFromCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename tag / Merge tags
     * @param {number} [collectionId] It\&#39;s possible to restrict rename action to just one collection. It\&#39;s optional
     * @param {RenameOrMergeTagsRequest} [renameOrMergeTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public renameOrMergeTags(collectionId?: number, renameOrMergeTagsRequest?: RenameOrMergeTagsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).renameOrMergeTags(collectionId, renameOrMergeTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect social network account as sign in authentication option
         * @summary Connect social network acount
         * @param {ConnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider: async (provider: ConnectSocialNetworkProviderProviderEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect social network account from available authentication options
         * @summary Disconnect social network account
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider: async (provider: DisconnectSocialNetworkProviderProviderEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('disconnectSocialNetworkProvider', 'provider', provider)
            const localVarPath = `/rest/v1/user/connect/{provider}/revoke`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currently authenticated user details
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get\'s publicly available user details
         * @summary Get user by name
         * @param {number} name Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName: async (name: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPublicUserByName', 'name', name)
            const localVarPath = `/rest/v1/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To change email, config, password, etc... you can do it from single endpoint
         * @summary Update user
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (updateCurrentUserRequest?: UpdateCurrentUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCurrentUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Connect social network account as sign in authentication option
         * @summary Connect social network acount
         * @param {ConnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectSocialNetworkProvider(provider, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.connectSocialNetworkProvider']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Disconnect social network account from available authentication options
         * @summary Disconnect social network account
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectSocialNetworkProvider(provider, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.disconnectSocialNetworkProvider']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get currently authenticated user details
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.getCurrentUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get\'s publicly available user details
         * @summary Get user by name
         * @param {number} name Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUserByName(name: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicUserByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUserByName(name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.getPublicUserByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCollectionStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCollectionStats(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.getSystemCollectionStats']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * To change email, config, password, etc... you can do it from single endpoint
         * @summary Update user
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(updateCurrentUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.updateCurrentUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Connect social network account as sign in authentication option
         * @summary Connect social network acount
         * @param {ConnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.connectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect social network account from available authentication options
         * @summary Disconnect social network account
         * @param {DisconnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: any): AxiosPromise<void> {
            return localVarFp.disconnectSocialNetworkProvider(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currently authenticated user details
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Get\'s publicly available user details
         * @summary Get user by name
         * @param {number} name Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserByName(name: number, options?: any): AxiosPromise<GetPublicUserByName200Response> {
            return localVarFp.getPublicUserByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get system collections count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCollectionStats(options?: any): AxiosPromise<StatResponse> {
            return localVarFp.getSystemCollectionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * To change email, config, password, etc... you can do it from single endpoint
         * @summary Update user
         * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Connect social network account as sign in authentication option
     * @summary Connect social network acount
     * @param {ConnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public connectSocialNetworkProvider(provider: ConnectSocialNetworkProviderProviderEnum, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).connectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect social network account from available authentication options
     * @summary Disconnect social network account
     * @param {DisconnectSocialNetworkProviderProviderEnum} provider facebook google twitter vkontakte dropbox or gdrive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disconnectSocialNetworkProvider(provider: DisconnectSocialNetworkProviderProviderEnum, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).disconnectSocialNetworkProvider(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currently authenticated user details
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get\'s publicly available user details
     * @summary Get user by name
     * @param {number} name Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUserByName(name: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getPublicUserByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get system collections count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSystemCollectionStats(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getSystemCollectionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To change email, config, password, etc... you can do it from single endpoint
     * @summary Update user
     * @param {UpdateCurrentUserRequest} [updateCurrentUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateCurrentUser(updateCurrentUserRequest?: UpdateCurrentUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateCurrentUser(updateCurrentUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type ConnectSocialNetworkProviderProviderEnum = typeof ConnectSocialNetworkProviderProviderEnum[keyof typeof ConnectSocialNetworkProviderProviderEnum];
/**
 * @export
 */
export const DisconnectSocialNetworkProviderProviderEnum = {
    Facebook: 'facebook',
    Google: 'google',
    Twitter: 'twitter',
    Vkontate: 'vkontate',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive'
} as const;
export type DisconnectSocialNetworkProviderProviderEnum = typeof DisconnectSocialNetworkProviderProviderEnum[keyof typeof DisconnectSocialNetworkProviderProviderEnum];


